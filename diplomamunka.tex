\documentclass[12pt]{report}

\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage{t1enc}

\usepackage{times}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{graphicx}
\graphicspath{{figures/}}

\usepackage[bottom,hang,flushmargin]{footmisc}

\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{xcolor}

% Margins
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 237mm

% URL style
\hypersetup{
    colorlinks=false, % Disable colorlinks for not coloring table of contents
    unicode=true,
}

\let\orighref\href
\renewcommand{\href}[2]{%
    \orighref{#1}{\textcolor{blue}{\texttt{#2}}}
}

\let\origurl\url
\renewcommand{\url}[1]{%
    \textcolor{blue}{\origurl{#1}}
}

\newcommand{\todo}[1]{%
    \textcolor{red}{\textbf{TODO}}\footnote{\textcolor{red}{\textbf{TODO:} #1}}
}

\newcommand{\fixme}[1]{%
    \textcolor{red}{\textbf{FIXME}}\footnote{\textcolor{red}{\textbf{FIXME:} #1}}
}

\setdescription{
    style=standard,
    align=right,
    itemindent=1cm,
    labelwidth=1cm,
    leftmargin=1cm,
    before={\renewcommand\makelabel[1]{\bfseries ########1:}},
    %font=\sffamily\bfseries,
}

\hyphenation{QtWebEngine QtWebKit WebKit Chromium Content Apple Google Quick Widget WebSocket
QtWebSockets QtWebChannel Android}

\def\title{A QtWebEngine bővítése és bemutatása saját böngészőalkalmazás segítségével}

\begin{document}

% EMPTY PAGE STYLE
\fancypagestyle{plain}{
    \fancyhf{}
    \fancyfoot[R]{\thepage}
    \renewcommand{\headrulewidth}{0pt}
}

% FOOTER & HEADER
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\title}
\fancyfoot[R]{\thepage}
%\fancyfoot[C]{\thepage}

%%% TITLE PAGE %%%
\thispagestyle{empty}
\begin{center}
    \vspace*{1cm}
    {\Large\textbf{Szegedi Tudományegyetem}}

    \vspace{0.5cm}
    {\Large\textbf{Informatikai Tanszékcsoport}}

    \vspace{3.8cm}
    {\LARGE\textbf{\title}}

    \vspace{3.6cm}
    {\Large Diplomamunka}

    \vspace{4cm}
    \begin{large}
        \begin{tabular}{c@{\hspace{4cm}}c}
            \emph{Készítette:}      & \emph{Témavezető:}        \\
            \textbf{Varga Péter}    & \textbf{Dr. Kiss Ákos}    \\
            programtervező          & egyetemi adjunktus        \\
            informatikus szakos     &                           \\
            hallgató                &
        \end{tabular}
    \end{large}

    \vspace*{2.3cm}
    \begin{Large}
        Szeged

        \vspace{2mm}
        2016
    \end{Large}
\end{center}


%%% TABLE OF CONTENTS %%%
\tableofcontents

%%% PROLOGUE %%%

\chapter*{Feladatkiírás}
\addcontentsline{toc}{section}{Feladatkiírás}

\noindent
A QtWebEngine bővítése úgy, hogy a QtWebKit-et használó fejlesztők könnyen portolhassák
a projektjüket QtWebEngine-re.
Továbbá, olyan új funkciók megvalósítása is fontos, amelyek hozzásegítik a
QtWebEngine-t, hogy lépést tartson a fejlődő web technológiákkal (pl. HTML5).
Az újonnan implementált funkciókat tesztelni kell.

\bigskip
\noindent
A tesztelésre lehetőséget nyújt a Qt \texttt{auto test}
keretrendszere, viszont bizonyos funkciók nem tesztelhetőek megfelelően \texttt{auto}
tesztekkel, továbbá nem biztosítható teljes lefedettség. A probléma kiküszöbölésére
példa alkalmazás(ok) implementálására van szükség, amelyet a fejlesztő használhat
``manuális'' tesztelésre, hibakeresésre, továbbá annak forráskódja a funkciók
dokumentálására, bemutatására is felhasználható.

\bigskip
\noindent
A fejlesztés során az alábbi szempontokat kell figyelembe venni:
\begin{itemize}
    \item Bináris kompatibilitás megtartása korábbi QtWebEngine verziókkal:
        publikus API-ban a változtatások számát minimalizálni kell,
        meglévő API-t (függvény, property, signal, stb.) módosítani vagy eltávolítani
        nem lehet.
    \item Törekvés kompatibilitásra a QtWebKit-el.
        A QtWebEngine-hez adott új API-k ne térjenek el (névben, paraméterezésben, stb.)
        az eredeti QtWebKit API-tól, hacsak ezt az új funkcionalitás bővítése nem indokolja.
    \item Törekedni kell arra, hogy a Quick és Widget API hasonlítson egymásra,
        amennyire csak lehet.
    \item Az új funkcionalitásokhoz \texttt{auto} tesztet kell készíteni,
        ahol ez megoldható.
    \item Qt 5.6-os verziójától minden új funkcionalitást dokumentálni kell.
\end{itemize}


\chapter*{Tartalmi összefoglaló}
\addcontentsline{toc}{section}{Tartalmi összefoglaló}
\begin{itemize}
    \item \textbf{A téma megnevezése:} \\
        \title
    \item \textbf{A megadott feladat megfogalmazása:} \\
        A QtWebEngine bővítése új funkciókkal és azok tesztelése a
        Qt teszt keretrendszerének segítségével. Az új funkciók bemutatása
        egy saját böngészőalkalmazás megvalósításával.
    \item \textbf{A megoldási mód:} \\
        Részvétel a QtWebEngine project fejlesztésében. Az új funkciók
        megvalósítása \texttt{C++} nyelven. Egy példa böngészőalkalmazás implementálása
        QtQuick használatával, \texttt{C++} és \texttt{QML} nyelven.
    \item \textbf{Alkalmazott eszközök, módszerek:} \\
        A fejlesztés GNU/Linux rendszeren, QtCreator fejlesztői
        környezetben (IDE) történt. A hibakereséshez GDB-t használtam.
        Makefile-ok legenerálását a project file-okból a qmake végzi.
        A project fordítása Linux-on a GNU Toolchain-el (GCC 5.3),
        Os X-en Xcode-al (Xcode 7.2.1), Windows-on pedig
        MSVC 2013 32-bites verziójával történt. A verzió-követéshez Git-et
        használtam. A teszteléshez szükséges keretrendszert és a teszteket a Qt
        repository-k tartalmazzák.
    \item \textbf{Elért eredmények:} \\
        A QtWebEngine 8 új funkcióval lett kibővítve. Ebből 4 a QtWebKit-ből
        átvett, 3 a tesztelést és hibakeresést segíti, 1 pedig HTML5 funkció.
    \item \textbf{Kulcsszavak:} \\
        \texttt{QtWebEngine}, \texttt{QtWebKit}, \texttt{QtQuick}, \texttt{Qt},
        \texttt{Chromium}, \\
        \texttt{Chromium Content API}, \texttt{Web}, \texttt{HTML5}, \texttt{WebKit},
        \texttt{Blink}, \texttt{C++}, \texttt{QML},\\
        \texttt{Quick}, \texttt{Widget}, \texttt{WebEngineView}
\end{itemize}

%%% CONTENT %%%

\chapter*{Bevezetés}
\addcontentsline{toc}{section}{Bevezetés}
A QtWebEngine-t 2013-ban kezdték el fejleszteni a Qt fejlesztői kísérleti jelleggel
a WebKit--Chromium szétválás után. A szétválás előtt a Qt fejlesztői csapata volt a harmadik
legtermékenyebb contributor-a (hozzájárulója) a WebKit kód bázisnak, az Apple és a
Google után. A kérdés adott volt: megtartsa e a Qt jól bevált QtWebKit komponensét és
maradjon az Apple szárnysegédje, vagy beálljon az új lehetőségeket és irányt mutató Google
mögé azáltal, hogy az ő web platformjára épít egy új API-t. Végül az utóbbi mellett
döntöttek, a QtWebKit projektet parkolópályára helyezték és a QtWebEngine éles lett.
\cite{bib:qt-blog-introducing-qtwebengine}

2014 elején kapcsolódtam be a projektbe és azóta is részmunkaidőben veszek részt a
fejlesztésekben. Az azóta eltelt több, mint 2 év alatt sokat tanultam a Qt-ról,
Chromium-ról és a web technológiákról, úgy egyáltalán. Dolgozatomban az ez idő alatt
gyűjtött tapasztalatokból szeretnék megörökíteni egy szeletet.

A QtWebEngine (korábban QtWebKit) projekt célja egy Qt modul (függvénykönyvtár) nyújtása a
fejlesztők számára, amelynek használatával könnyedén integrálhatnak böngésző
funkcionalitásokat saját Qt alkalmazásaikba vagy könnyedén valósíthatnak meg Qt platform
felett saját böngészőt. Ráadásul, mindezt úgy tehetik meg, hogy nincs szükségük semmilyen
ismeretre arról, hogy egy böngésző, hogyan működik a motorháztető alatt.

Dolgozatomat 3 részre tagoltam. Az első részben adok áttekintést arról, hogy mi is az a
Chromium, mi a Qt, ezek hogyan kapcsolódnak egymáshoz és hogyan is lesz ebből QtWebEngine.
A második részben összegyűjtöttem 8 olyan funkcionalitást (feature-t), amit magam
fejlesztettem és adtam hozzá a QtWebEngine-hez. Röviden leírom, hogyan valósítottam meg
őket, mi volt a célom velük és milyen nehézségekkel kellett szembe néznem a megvalósítás
során.

A legutolsó fejezetben szeretném bebizonyítani, hogy könnyű a QtWebEngine-el böngészőt
készíteni. Sajnos a Chromium erőforrás igénye és a magas szintű API-ja miatt, nem várható el
a QtWebEngine-től, hogy lekörözze sebességben és/vagy memória-fogyasztásban a versenytársakat.
A QtWebEngine igazi előnye kétség nélkül az egyszerű használhatóságban és a cross-platform
támogatásban rejlik.


\chapter{Áttekintés: \mbox{Chromium + Qt = QtWebEngine}}

\section{Chromium}
A Chromium a Google által fejlesztett, nyílt forrású (open source) web böngésző projekt. Nagy
része \texttt{C++} nyelven íródott. Támogatja napjaink legnépszerűbb operációs rendszereit \\
(``cross-platform''), legyen az desktop (Windows, Linux, OS X) vagy mobil (Android, iOS,
QNX).
A Chromium nem egy böngésző alkalmazás, hanem egy tabokat használó ablakkezelő (vagy shell)
a web-hez.
\cite{bib:wiki-chromium}

\subsection{Chrome}
A Google saját Chromium-ra épülő böngésző alkalmazása a Google Chrome.
Ez az alkalmazás Chromium-mal szemben nem nyílt forrású, viszont a böngésző
megvalósításának nagy része a Chromium projektben megtalálható.
A Chrome nem nyílt részei például a beépített Adobe Flash Player (Pepper Flash Player)
és az automatikus frissítésekért felelős komponens (GoogleUpdate). \cite{bib:wiki-chrome}
Egy másik, szintén népszerű Chromium-ra épülő böngésző alkalmazás az Opera.

\subsection{Blink}
A Chromium 28-as verziójától kezdve a Blink böngésző motort használja.
A böngésző motor elsődleges feladata a webes tartalom megjelenítése a képernyőn. Talán
ebből is látszik, hogy a Blink talán a legfontosabb komponense a Chromium-nak.
A Chromium a 28-es verzió előtt WebKit-et használt, a Google ezt a projektet forkolta és
nevezte el Blink-nek. Pontosabban, annak csak egy részét, név szerint a WebCore-t.
\cite{bib:wiki-blink}

A Blink nem tartalmazza a WebKit-ben alkalmazott multi-processz architektúrát és sandbox
megoldást, ezek a feladatok a Chromium más szintjein vannak megvalósítva, így egyszerűbbé
téve a Blink forráskódját.
Továbbá, a WebKit része JavaScriptCore JavaScript motor is, ami a Blink-be már nem került
bele, hiszen a Chromium-nak van sajátja, a V8. Ezektől eltekintve a Blink még mindig nagyon
hasonlít a WebCore-ra/WebKit-re. A Chromium forrásában és könyvtár struktúrájában továbbra is
``WebKit'' néven hivatkoznak erre a komponensre\footnote{Például, a Blink forrása a
\texttt{third\_party/WebKit} könyvtárban található a Chromium repository-n belül}.
\cite{bib:chromium-displays-web-pages, bib:chromium-blink}

A Blink az a komponens, ami a weboldal tartalmát feldolgozza és előkészíti megjelenítésre.
Az oldal tartalmát először parse-olja és a HTML elemekből \texttt{Node} objektumokat gyárt.
Ezeket a \texttt{Node}-okat egy fába rendezi, amit DOM (Document Object Model) fának hívnak.
A DOM fának a gyökér \texttt{Node}-ja mindig, az úgynevezett, \texttt{Document Node}.
A fa építése során, a motor, minden megjeleníthető \texttt{Node}-hoz egy
\texttt{RenderObject}-et rendel. A \texttt{RenderObject} az az elem, ami ``tudja'',
hogyan kell a hozzátartozó \texttt{Node}-ot megjeleníteni.
A DOM fa építésével párhuzamosan, a Blink egy másik fát is épít a
\texttt{RenderObject}-ekből, ez a \texttt{Render Tree}. Továbbá, bizonyos
\texttt{RenderObject}-hez \texttt{RenderLayer}-t is rendel, amiből egy újabb fát épít,
ami pedig a \texttt{RenderLayer Tree}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.46]{rendering-trees}
    \caption{
        \label{fig:rendering-trees}
        Rendering Trees (forrás: \url{https://www.chromium.org} \cite{bib:chromium-oopifs})
    }
\end{figure}

\noindent
Az \ref{fig:rendering-trees} ábra szemlélteti, hogyan is állnak össze ezek a struktúrák.
A \texttt{DOM Tree} és a \texttt{Render Tree} szinte azonos, annyi különbséggel, hogy
a \texttt{Render Tree} csak a megjeleníthető \texttt{Node}-okat tartalmazza.
A \texttt{RenderLayer Tree} a \texttt{Render Tree} egy lecsupaszított változata, amit a
megjelenítő komponens (renderer) fog használni a rajzoláshoz.
A \texttt{RenderLayer}-ből elérhetőek a \texttt{RenderObject}-ek, a \texttt{RenderLayer Tree}
szerkezete pedig, hordozza azt az információt, hogy milyen sorrendben kell kirajzolni
\texttt{RenderObject}-eket és, hogy azok között milyen átfedések lehetnek.

Az, hogy a rajzolás hogyan történik az függ attól, hogy van e elérhető hardveres gyorsítás.
Ha nincs, akkor szoftveres renderelés történik. A szoftveres renderelés során a rajzoló
algoritmus bejárja a \texttt{RenderLayer Tree}-n keresztül a \texttt{RenderObject}-eket és
azokat egy közös bitmap-re rajzoltatja ki. Ha kész, ez a bitmap lesz elküldve egy másik
processz (browser process) számára megjelenítésre. Szoftveres renderelés esetén a rajzolást
a Skia grafikus motor végzi.

Ha van elérhető hardveres gyorsítás, akkor az eljárás valamivel bonyolultabb. Ebben az
esetben, a \texttt{RenderObject} nem bitmap-be ``rajzolja bele magát'', hanem 3D API-n
keresztül (OpenGL vagy Windows-on esetleg D3D) utasításokat küld közvetlenül a GPU
utasítás pufferébe (command buffer) végrehajtásra. Ezt az eljárást már a
Chrome Compositor (CC) végzi.
\cite{bib:chromium-gpu, bib:chromium-oopifs}

\subsection{Chrome Compositor (CC)}
A Chrome Compositor már nem része a Blink-nek (ahogy a Skia sem). Ennek az az oka,
hogy most már a Chromium a browser UI megrajzolásához is a Chrome Compositor-t használja.
Ahhoz, hogy a compositor ki tudja rajzolni a DOM-ban tárolt tartalmat, további layer
absztrakciókra van szükség:
\begin{center}
    \texttt{RenderLayers} $\rightarrow$ \texttt{GraphicsLayers} $\rightarrow$
    \texttt{WebLayers} $\rightarrow$ \texttt{CC Layers}
\end{center}

A compositor a végeredményt nem bitmap-be, hanem textúrába ``rajzolja''. Az elkészült
textúrák a GPU memóriájában vannak tárolva és úgy nevezett texture mailbox segítségével
azonosítják. A texture mailbox egy OpenGL extension kiterjesztés, ami egyedi és globális
string azonosítót rendel a textúrához és lehetővé teszi, hogy más OpenGL context-en
is elérhető legyen a textúra, ami normális esetben nem lenne megosztva.
\cite{bib:chromium-gpu, bib:chromium-oopifs}

A texture mailbox-nak hála az összeállított képet nem kell az IPC-n (Inter-Process
Communication) keresztül megosztani a processzek között (mint a szoftveres rendering
esetében), hanem a GPU memórián keresztül bármelyik processz hozzáférhet a textúrához, így
elég csak a textúra azonosítót átküldeni IPC-n.
\cite{bib:chromium-texture-mailbox}

\subsection{Multi-processz Architektúra}
Chromium volt az egyik első olyan böngésző, ami úgy lett megtervezve, hogy több processzre
legyen felosztva. A WebKit multi-processz architektúrára épülő API-ja (WebKit2) is a
Chromium-ról vette a mintát. \cite{bib:webkit-webkit2}
Ez az API a Blink-nek nem része, viszont a QtWebEngine elődjének, a QtWebKit-nek
Quick API-ja a WebKit2-re épül.

A multi-processz architektúrán alapuló böngésző alapgondolata az, hogy a böngészőalkalmazás
UI-ért felelős része saját processzben fut, míg a weboldalak megjelenítésért más
processzek felelnek. Ennek több előnye is van: \cite{bib:chromium-blog-multi-process}
\begin{description}
    \item[Felhasználói élmény]
        Előfordulhat, hogy egy weboldalon futó script (vagy ``webalkalmazás'')
        nagyon leterheli a böngészőt. Ha ez a script és a UI egy processzben fut,
        akkor ezek nagyobb valószínűséggel vonnak el egymástól erőforrást. Ha külön
        processzben, egymástól függetlenül futnak, kisebb valószínűséggel alakul ki
        köztük versenyhelyzet, így a UI nagyobb CPU használatnál is ``reszponzívabb''
        lehet.
    \item[Biztonság]
        Egyes processzek sandbox-ban futhatnak. Ezáltal nem férhetnek hozzá a rendszer
        olyan erőforrásaihoz, ami veszélyes lehet (pl. merevlemez, hálózat,
        videó memória, stb).
        Továbbá a különböző weboldalakat megjelenítő processzek egymástól is el vannak
        különítve, így egy ártalmas oldal, vagy plugin nem férhet hozzá más oldalon használt
        szenzitív információhoz (pl. jelszó).
    \item[Hibatűrés, Robosztusság]
        Ha egy oldal betöltésekor vagy egy bővítmény futtatásakor hiba történik és
        összeomlik, az nem rántja magával a teljes böngészőt. Hiba esetén a UI és más
        megnyitott oldalak, tabok megmaradnak.
    \end{description}

A multi-processz architektúrának hátrányai is vannak: ez a megoldás sokkal \\
erőforrás-igényesebb, és a megvalósítás is bonyolultabb (több hibalehetőség).
A processzek használata memória többletköltséggel jár. Továbbá, a futtatható processzek
számát limitálni kell, mert túl sok processz jelentős lassulást okozhat (pl. az ütemező
többletköltsége miatt).

A processzek IPC-n (Chromium's IPC System) keresztül kommunikálnak egymással.
A Chromium-ban 4 fő processz típust különböztetünk meg:

\subsubsection{Browser Process}
Ez az a processz, ahol maga böngésző alkalmazás (UI) fut. Ez felelős megjelenítésért,
a felhasználói események és a tabok kezeléséért. Ez a fő processz, ami a többi processzt
kezeli (indítja, leállítja, stb.) és csak egy van belőle. Hozzáfér a rendszer erőforrásaihoz,
viszont nem tölt be vagy dolgoz fel web tartalmat.

\subsubsection{Render Process}
A renderelő motor egy nagyon összetett és bonyolult szoftver komponens. Szinte lehetetlen
olyat implementálni, ami sosem hibázik és/vagy omlik össze. \cite{bib:chromium-multi-process}
Ezért racionális döntés az egymástól független oldalak renderelését egymástól független
processzekben végrehajtani. Amennyiben egy Render Process összeomlik, arról a
Browser Process értesül és az oldal helyett az \ref{fig:sad-tab} ábrán látható,
úgynevezett, ``sad tab'' értesítést jeleníti meg.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{sad-tab}
    \caption{
        \label{fig:sad-tab}
        Sad Tab
    }
\end{figure}

Mivel a Chromium-ban a renderelésért a Blink felel, ezért az is a Render Process-ben fut.
A Blink az, ami közvetlenül feldolgozza a webes tartalmat, ezért jellemzően a
Render Process-t sandbox-ban futtatják, így a potenciálisan kártékony webes kódok nem
férhetnek hozzá a rendszer erőforrásaihoz vagy más betöltött webes tartalomhoz.

A Chromium-ban különböző parancssori kapcsolókkal is beállítható processz modellek
vannak definiálva:
\begin{description}
    \item[Process-per-site-instance]
        Minden site\footnote{Site alatt olyan weboldalak csoportját értjük, amelyek
        közös beregisztrált domain néven osztoznak} külön processz.
        Ha ugyanaz a site kétszer van megnyitva, akkor az is két külön processz lesz.
    \item[Process-per-site]
        Különböző site-ok külön processzbe kerülnek. Az előzővel ellentétben, ha egy site
        kétszer van megnyitva, akkor azok közös processzbe kerülnek.
    \item[Process-per-tab]
        Minden tab külön processz. Több tab kerülhet közös processzbe, ha függnek egymástól.
    \item[Single Process]
        A ``hagyományos, egy-processzes'' modell. \\
        Nincs külön Render Process. A rendering a Browser Process-ben történik.
\end{description}

\noindent
Alapértelmezetten a \textit{Process-per-site-instance} modellt használja a böngésző, de
ettől függetlenül előfordulhat, hogy több site is osztozik, ugyanazon a processzen.
Erre vagy akkor van szükség amikor két site hivatkozik script-ből egymásra,
vagy amikor a futó Render Proess-ek száma elér egy limitet.
\cite{bib:chromium-process-models}

\subsubsection{Plugin Process}
A pluginok okozzák a legtöbb problémát a böngésző stabilitásának szempontjából. A plugint
egy harmadik fél készíti ezért a Chromium-nak nincs befolyása afelett, hogy milyen
erőforrásokat használ. Ennél fogva, indokolt lépés a pluginokat nem a Browser Process-ben
futtatni. A legtöbb plugin nem futhat sandbox-ban, mivel olyan
képességekkel bővítik a böngészőt, amelyekhez szükség van hozzáférésre a rendszer
erőforrásaihoz. Ezért a Render Process-en kívül szükség van egy újabb processz típusra is,
amelyben a pluginok futhatnak.
\cite{bib:chromium-plugins}

\subsubsection{GPU Process}
A renderelés a Render Process-ben történik, viszont ez a processz sandbox-ban fut és ezért
nem küldhet parancsokat GPU-nak. Hardveres gyorsítás esetén a compositing-ot és a rajzolást
egy külön processzben kell végezni, ami nem sandbox-ban fut.
\cite{bib:chromium-gpu} \\
A Chromium úgy is konfigurálható, hogy a GPU Process feladatát a Browser Process lássa el.

\subsection{Chromium Content Module}
A Content Module a Chromium az a része, ami megvalósítja az előző fejezetben bemutatott
multi-processz architektúrát. Továbbá, ebben van megvalósítva az összes támogatott
web platform funkcionalitás (például: HTML5, WebRTC, WebGL, stb.), illetve
a hardveres GPU gyorsítás. Böngészőalkalmazás specifikus funkcionalitások, nem részei
Content Module-nak. Lényegében csak az van benne, ami a web tartalom
megjelenítéséhez\footnote{\textit{content} = web tartalom} szükséges, azaz olyan kód,
amit minden böngészőt integráló alkalmazásnak szüksége van.
\cite{bib:chromium-content-module}

A modul célja, hogy az opcionális böngésző funkcionalitások (amire nem feltétlenül van
szüksége a beágyazó alkalmazásnak (pl. Chrome) le legyenek választva, ezáltal
megvalósíthatóak és testreszabhatóak legyenek a beágyazó alkalmazásban anélkül,
hogy a Chromium forráskódját módosítani kellene. Erre nyújt lehetőséget a Content API.

\subsubsection{Chromium Content API}
A Content API megtervezésekor a WebKit API-t vették alapul, hogy a WebKit fejlesztők
könnyebben áttérhessenek. Az új API \textit{unstable}, ami azt jelenti, hogy az API minden
új kiadásban változhat, ezért a beágyazó alkalmazást is minden Chromium frissítés után nagy
valószínűséggel változtatni kell.

A Content Module a beágyazó alkalmazást interfészeken (Delegate, Observer)
és callback függvényeken keresztül értesíti az eseményekről, változásokról (például,
hol tart a web oldal letöltése vagy sikeres volt-e a letöltés) vagy éppen
kér le adatokat (például, kell megjeleníteni hiba üzenetet, ha nem sikerül letölteni egy
oldalt). Az ilyen interfészek metódusainak törzse üres a Content Module-ban, ezeket a
beágyazó alkalmazásnak kell megvalósítania és a Content Module hívja meg őket szükség esetén.

Ezeken kívül vannak olyan interfészek is, amelyeket a Content Module implementál
(például, oldal betöltése: \texttt{LoadURLWithParams()} vagy az URL lekérdezése: \\
\texttt{GetVisibleURL()}).
Ezek az interfészek \textit{pure abstract} interfészek, mivel csak egy megvalósításuk lehet
és az is a Content Module-on belül. \cite{bib:chromium-content-api}

\subsubsection{Chromium Content Shell}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{content-shell}
    \caption{
        \label{fig:content-shell}
        Content Shell
    }
\end{figure}

\noindent
Az \ref{fig:content-shell} ábrán látható alkalmazás a Content Shell. Ez a lehető
legegyszerűbb böngészőalkalmazás, ami a Content API-ra épül. Arra használják, hogy a
Content Module-t és a Blink-et tesztelhessék, debuggolhassák anélkül, hogy egy teljes
böngészőalkalmazást (pl. Chrome) le kellene fordítani.

\subsection{Felépítés}
Az eddigiek alapján a Chromium-ot 3 rétegre oszthatjuk fel:
\begin{description}
    \item[Chrome]
        Felhasználói felület (UI) és böngészőalkalmazás funkciók
        (pl.: history, könyvjelzők, favicon, stb.)
    \item[Blink]
        Webes tartalom feldolgozása és renderelése. A V8 JavaScript motort a
        Blink-en keresztül érjük el és közös processzben futnak.
    \item[Content]
        Ez a réteg valósítja meg a multi-processz architektúrát,
        felel a web platform funkciókért és a hardveres GPU gyorsításért.
\end{description}
A \ref{fig:chromium-architecture} ábra mutatja, hogyan is állnak össze a Chromium rétegei.
Itt a Blink böngészőmotor még ``WebKit''-nek van jelölve.
A legfelső réteg a Chrome, helyére a saját beépítő alkalmazás kerül.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{chromium-architecture}
    \caption{
        \label{fig:chromium-architecture}
        Chromium Architecture
        (forrás: \url{https://www.chromium.org} \cite{bib:chromium-content-module})
    }
\end{figure}


\subsection{Release}
Egy Chromium release verzió száma 4 részből tevődik össze:
\begin{verbatim}
    MAJOR.MINOR.BUILD.PATCH
\end{verbatim}
A dolgozatomban a főverzió számra (\texttt{MAJOR}) hivatkozok.
A Chromium közösség előre tervezett menetrend szerint 1-1.5 havonta vált főverzió számot
(ad ki új release-t).
Dolgozatom készítése idején az 51-es verziójú volt a legfrissebb stabil kiadás.
Az itt leírtak erre a verzióra vonatkoznak.


\section{Qt}
A Qt egy nyílt forrású, cross-platform alkalmazás keretrendszer. Úgy ahogy a
Chromium úgy a Qt is elérhető napjaink legnépszerűbb desktop és mobil
operációs rendszerein. Ez a keretrendszer nyújt \texttt{C++} függvénykönyvtárakat (library),
binding-okat más programozási nyelvekhez (pl.: Python, Java), saját programozási nyelvet
(\texttt{QML}), saját integrált fejlesztői környezetet (QtCreator), saját build rendszert
(qmake) és kiterjesztéseket is a \texttt{C++} programozási nyelvhez (pl.: signal-slot model).
\cite{bib:qt-wiki-about-qt}

\subsection{Történelem}
\subsubsection{1995-2000}
A Qt első verziója 1995-ben adta ki a Trolltech. Akkor még a projekt egy
cross-platform GUI fejlesztői keretrendszernek indult.
Nem sokkal később (1998-ban), jelent meg a
KDE (K Desktop Environment) első verziója, amely Qt-re épült.
A KDE egyhamar az egyik legnépszerűbb Linuxos asztali környezetté nőtte ki magát
és talán ennek tudható be a Qt népszerűsége is.
A Qt eszköztára az évek során fokozatosan
bővült. Új API-k jelentek meg adatbázis kezeléshez (SQL), hálózati programozáshoz,
multimédiás alkalmazások készítéséhez, XML dokumentumok feldolgozásához stb.

\subsubsection{2000-2008}
2000-ben megjelent a Qt-ra épülő Qt/Embedded keretrendszer Linux-os beágyazott eszközökre.
Ezzel az új technológiával a Qt meg is jelent az első okos telefonokon (2003: Motorola A760)
és a korabeli PDA-kon. 2006-ban a Trolltech még a saját fejlesztésű mobil telefonját is
kiadta, Greenphone néven.

\subsubsection{2008-2011}
Talán a Trolltech beágyazott platformokon és mobil telefonokon szerzett tapasztalata
miatt került arra sor, hogy 2008-ban, az akkori egyik vezető mobiltelefon gyártó, a Nokia,
felvásárolta a céget. A következő pár évben a fejlesztés még inkább a mobil eszközök
felé irányult, olyannyira, hogy azokon a részeken, melyek nem voltak érintettek mobil
fejlesztés szempontjából jóformán nem is történt fejlesztés.
2010-ben kiadott 4.7-es verzióban két nagyon fontos újítás (teljesen új modul) jelent meg:
a QtWebKit és a QtQuick.

A WebKit az Apple által fejlesztett nyílt forrású böngésző motor, a QtWebKit pedig ennek
a ``Qt portja''. Ez azt jelenti, hogy az API természetesen ``Qt-s'', továbbá a legfontosabb
``alacsony szintű'' feladatokat is a Qt látja el, mint például a hálózat kezelés
(pl. tartalom letöltése) és az oldalak kirajzolása (renderelése).
Ironikus a történetben, hogy a WebKit elődjei a KHTML és KJS projektek, melyek a KDE
keretrendszer részei voltak, ennélfogva a Qt-ra épültek. Amikor 2001-ben az Apple
fejlesztői forkolták ezeket a library-kat, a céljuk éppen az volt, hogy a Qt-tól független
böngésző motort valósítsanak meg.

A Qt 4.7-es verzió másik nagyon fontos újítása a QtQuick és a \texttt{QML}.
Ez az új technológia a mobil fejlesztés szempontjából nagyon fontos. A \texttt{QML} egy
új deklaratív programozási nyelv, a QtQuick pedig a hozzátartozó eszközkészlet vagy
``függvénykönvytár''. Ezek segítségével a Qt egy új megközelítést nyújtott GUI
megvalósítására. A legnagyobb előnye (a könnyű használhatóságot és a gyors fejlesztési
ciklust nem számítva), hogy mobil alkalmazás felhasználói felületének
lefejlesztéséhez nincs szükség szimulátorra, hiszen a \texttt{QML}-ben írt alkalmazás
platform független és ugyanúgy fut/néz ki desktop-on mint mobilon.

\subsubsection{2011-2013}
2011 elején a Nokia szerződést kötött a Microsoft-tal. A Nokia készülékek elsődleges
platformja a Windows Phone lett, így a Nokia elkezdte fokozatosan leépíteni a
szoftver kutatás-fejlesztés részlegét. 2012-re a Qt teljes egészében a Digia
tulajdonába került.

A 2012-es év más változást is hozott, az év végén megjelent a Qt 5.0-ás verziója.
Az új verzió API-ja nem sokban tér a 4-estől, ami azt jelenti, hogy az új API szinte
teljesen kompatibilis maradt. Az igazán fontos változás a Qt kód struktúrájában jelent meg.
A 4-es verzióban a kódot már modulokra bontották, hogy a Qt-s alkalmazások méretét
csökkentsék azzal, hogy a nem használt modult (gyakorlatilag library-t) nem linkelik
az alkalmazáshoz. Az 5-ös verzióban a fejlesztők tovább mentek: a keretrendszert több,
kisebb modulra bontották és az összetartozó modulokat közös repository-ba rakták
(komponensek). Ezzel megszűnt a 4-es verzió ``egy-repositorys'' modellje és így a
modulok/komponensek egymástól függetlenül is kiadhatóvá, verziózhatóvá váltak.
Az új repository-kat a \texttt{qt5} top-level repository köti össze.
Ez hivatkozásokat (git submodule) tartalmaz a modulok repository-jaira, itt találhatóak meg a
build-hez szükséges scriptek egy része és más build-hez szükséges platform specifikus fájlok
(QPA plugin-ok, mkspecs, stb.) is.

Az 5-ös verzió másik újítása QtQuick2 volt. A QtQuick első verziója (QtQuick1) a
\texttt{QGraphicsView}-ra épül, ami szoftveres renderelést használ a megjelenítéshez.
Ez a megoldás lassú, ráadásul widget függősége is van. A QtQuick2 API-ja kompatibilis a
QtQuick1-el, viszont teljesen újraírták. Nincs többé widget függőség mivel ezentúl a
QtQuick2 a saját Qt Quick Scene Graph-ot valósít meg. Ez a scene graph Open GL ES 2.0-ra vagy
Open GL 2.0-ra épül, így a renderelés a GPU-n történik. Ez a megoldás sokkal gyorsabb,
viszont nem működik olyan platformokon ahol nincs OpenGL 2.0.

2013-ban a Qt fejlesztői úgy döntenek szakítanak a WebKit-el és, hogy böngésző motor
API-jukat ezentúl a Chromium felé építik. \cite{bib:qt-blog-introducing-qtwebengine}
Az új komponenst QtWebEngine-nek hívják és 5.4-es verzióban jelent meg először.
\cite{bib:qt-wiki-qt-history}

\subsubsection{2014-napjainkig}
2014-ben a Qt részlege kivált a Digia-ból és létrejött a \textit{The Qt Company},
mint a Digia leányvállalata. A kiválás oka, hogy a Qt üzleti logikája és piaca eltér a
Digia-étól, ezért másfajta vezetésre, fejlesztésre és befektetési tervre van szükség.
Ez a folyamat még 2016-ban is tart és terv szerint 2016 májusában a The Qt Company megjelenik
a tőzsdén is.
\cite{bib:qt-about-us}

A Qt hányattatásai ellenére még ma is töretlen népszerűségnek örvend és talán az egyik
legjobb legjobb \texttt{C++} alkalmazás keretrendszer a piacon. Ezt bizonyítja,
hogy több, napjainkban is népszerű és széles körben elterjedt alkalmazás is a
Qt keretrendszerre épül. Ilyenek például a Skype, a Google Earth, a VirtualBox,
a VLC média lejátszó és a Spotify is.

\subsection{Modulok és Komponensek}
A 4-es Qt verzióban megtörtént az első lépés a modularizáció felé: minden modulnak külön
library-ként jelenik meg ahelyett, hogy egy nagy közös library-je lenne a Qt-nak.
Ennek előnye, hogy a fejlesztőnek nem kell olyan modulokat az alkalmazásához linkelnie,
amit nem is használ.

Az 5-ös Qt verzióban kiterjesztették a modularizációt a projekt struktúrájára is. A projekt
többé nem egy nagy közös repository, hanem több önálló repository-ból áll össze, melyeket
a modulok szerint választottak el. Ennek előnye, hogy egyes modulok külön is release-elhetőek
(egyes modulok gyorsabban fejlődnek, mások nem), a tesztelés és buildelés rugalmasabb és
gyorsabb lett, hiszen nem kell mindig a teljes rendszert tesztelni vagy buildelni.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.66]{qt-repos-and-modules}
    \caption{
        \label{fig:qt-repos-and-modules}
        Qt repository-k és modulok
    }
\end{figure}

Továbbá, Qt 5 óta a modulokat két kategóriába sorolják: \textbf{Qt Essentials} és
\textbf{Qt Add-Ons}. A Qt Essentials-ba tartoznak azok a modulok, amelyek működnek az
összes támogatott platform-on és a legtöbb Qt alkalmazás használja is őket. Ezeknek a
moduloknak az API-ja az 5-ös verzión belül visszafele kompatibilis marad.
A Qt Add-on modulok nem általános célú, "opcionális" modulok. Vannak köztük olyanok,
amelyek nem használhatóak bizonyos Qt által támogatott platformokon vagy olyanok, amelyek
hamarosan eltávolításra kerülnek a Qt keretrendszerből, csak kompatibilitási okokból vannak
még bent (pl. QtScript). A QtWebEngine moduljai is Qt Add-On kategóriába vannak sorolva,
hiszen a legtöbb alkalmazásnak nincs szüksége böngésző funkciókra. API kompatibilitás
szabályait minden Add-On modul saját magának határozza meg.
\cite{bib:qt-doc-qtmodules}

Ha egy Qt-s alkalmazás használ egy Qt modult, akkor azt annak a projekt file-jában
(\texttt{.pro}) meg kell adni:
\begin{verbatim}
    QT += network widgets qml quick
\end{verbatim}
Ez alól kivétel a \texttt{QtCore} és a \texttt{QtGUI} modul. A \texttt{QtCore} modult
minden Qt-s alkalmazás használja, ezért azt a Qt build rendszere implicit linkeli.
Ebben a modulban vannak megvalósítva a Qt típusok és adatszerkezetek, a Qt specifikus nyelvi
elemek és makrók (pl.: \texttt{Q\_OBJECT}, \texttt{signals}, \texttt{slots}),
smart pointerek, stb. A \texttt{QtGUI} modulra a grafikus felhasználói felület
megvalósításához van szükség, de nem kötelező használni (explicit le lehet tiltani).
A \texttt{QtGUI} modulról bővebben a \ref{sec:qt-gui} fejezetben lesz szó.

Ahogy a Qt-s alkalmazások, használnak egy Qt-s modult, úgy a Qt-s modulok is használják
egymást. Az alkalmazáséhoz hasonlóan a modul projekt file-jában is meg kell adni a
függőséget. Továbbá, ha egy komponens modulja használja egy másik komponens modulját, akkor
a komponensek közötti függőséget külön jelezni kell. Erre a ``felhasználó'' komponens
\texttt{sync.profile} script-jében van lehetőség:
\begin{verbatim}
    %dependencies = (
        "qtbase" => "",
        "qtdeclarative" => "",
        "qtxmlpatterns" => "",
        "qtquickcontrols" => "",
        "qtwebchannel" => "",
    );
\end{verbatim}

\noindent
Ebben az esetben, a komponensre, mint a modult tároló repository-ra kell
gondolni\footnote{Tovább bonyolítja a helyzetet, hogy sok esetben a komponenseket is
``modul'' elnevezéssel illetjük. Például: ``a QtWebEngine modul függősége a QtBase modul''},
ezért, ha a \texttt{QtCore} modul minden más modul függősége, értelemszerűen az őt tartalmazó
\texttt{QtBase} komponens minden más komponens függősége is lesz, amit ezen a szinten
még explicit meg kell adni.
Az \ref{fig:qtwebengine-dependencies} ábra mutatja, hogy a fenti \texttt{sync.profile} script
alapján a QtWebEngine függőségei hogyan alakulnak.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.66]{qtwebengine-dependencies}
    \caption{
        \label{fig:qtwebengine-dependencies}
        QtWebEngine függőségei
    }
\end{figure}

\subsection{GUI}
\label{sec:qt-gui}
A Qt keretrendszer grafikus felhasználói felületek (GUI) megvalósítására gazdag
eszközkészletet kínál a fejlesztők számára. A QtGUI modul az, amely alacsony szintű API-t
nyújt 2D (rasztergrafika) és 3D (OpenGL API) rajzoláshoz, esemény kezeléshez, képek és
szövegek megjelenítéséhez. A Qt build rendszere automatikusan linkeli ezt a modult az
alkalmazásunkhoz, feltételezvén azt, hogy az úgy is rendelkezik GUI-val. Ha ez nem így
lenne, a QtGUI modul letiltható ha a következő sort adjuk GUI nélküli alkalmazás
projekt file-jához:
\begin{verbatim}
    QT -= gui
\end{verbatim}

Egy grafikus felület megvalósításához nem érdemes csak a QtGUI modult használni. A Qt nyújt
magasabb szintű, QtGUI-ra épülő API-kat is. Jelenleg két egymástól eltérő megközelítés
elérhető: a \textbf{Widget} és a \textbf{Quick}.
\cite{bib:qt-doc-qt-gui, bib:qt-doc-user-interfaces}

\subsubsection{Widget}
A widget API-n keresztül a ``klasszikus'' felhasználói felületeket lehet megvalósítani,
melyeknek megjelenítéséhez a Qt a futtató operációs rendszer stílusát adja\footnote{
\textit{native look'n'feel}}. A widget-ek jellemzően olyan statikus GUI elemek, amelyek
általában desktop-on használt alkalmazások használnak. Megjeleníthetnek vagy tárolhatnak
információt és/vagy felhasználói eseményeket kezelhetnek. Például: gomb (\texttt{QButton}),
címke (\texttt{QLabel}), görgetősáv (\texttt{QScrollBar}), stb. Az a widget, aminek nincs
szülője, az ablak.
\cite{bib:qt-doc-qt-widgets}

A Qt beépített widget-jei a \textbf{QtWidgets} modulból elérhetőek, de saját widget-ek is
készíthetőek. A widget-ek tartalmát a \texttt{QGraphicsView} jeleníti meg. A rajzolás
szoftveresen történik, nincs hardveres gyorsítás.

A QtWidgets modul a widget-eken túl még tartalmaz API-t a widget-ek megjelenítésének
testreszabásához (\texttt{QStyle}) és beépített stílusokat is natív megjelenéshez különböző
platformokon. A widget-ek elrendezésére a beépített \texttt{QLayout} osztályok használhatóak.

A widget alapú GUI-t első sorban \texttt{C++} API-n keresztül lehet felépíteni, de a Qt
keretrendszer tartalmaz egy Qt Designer elnevezésű eszközt is, aminek segítségével,
akár programozási ismeret nélkül össze lehet állítani a GUI-t. A Qt Designer a widget-eket
fába rendezi és XML formátumban tárolja egy \texttt{.ui} kiterjesztésű file-ban. Az XML
file-ból a User Interface Compiler (uic) generál buildelhető \texttt{C++} forrás állományt.

\subsubsection{Quick}
Az új Quick technológia segítségével modern megjelenésű, dinamikus elemekből felépített,
``fluid'' GUI-t lehet összeállítani. Megvalósítás ``deklaratív módszerrel'' történik, ami
magasabb szintű, mint a widget API esetében használatos imperatív paradigma: nem azt kell
leprogramozni, hogyan legyen megjelenítve a GUI, hanem azt, hogy hogyan nézzen ki
(mint például a HTML esetében). A technológia használatához alapvetően 2 modulra van
szükség: \textbf{QtQml}-re és a \textbf{QtQuick}-re.

A Qt egy saját nyelvet nyújt a deklaratív programozáshoz és ez \texttt{QML} (Qt Modeling
Language). Ez a nyelv a \textbf{QtQml} modulon keresztül válik elérhetővé.
A modul rendelkezik \texttt{C++} és \texttt{QML} API-val is, hogy \texttt{QML} nyelv saját
típusokkal és  funkciókkal bővíthető legyen.
A Quick GUI akár ezen a \texttt{C++} API-n keresztül is megvalósítható, de erre a célra
sokkal inkább a \texttt{QML} nyelv használata ajánlott.
A \texttt{QML} nyelv ``JSON-szerű'' szintaxison keresztül írja a UI komponensek
hierarchiáját és kapcsolatait. A \texttt{QML} programot egy külön erre a célra fejlesztett
\texttt{JavaScript} motor dolgozza fel, a \textit{v4}. Ezáltal lehetővé válik, hogy a
UI kódja akár futásidőben is dinamikusan változtatható legyen. \texttt{JavaScript}
kód szabadon hozzáadható a \texttt{QML} forráshoz, így akár logikát is meg lehet valósítani a
\texttt{QML} programon belül. \texttt{JavaScript} használatánál érdemes csak az
eseménykezelésre szorítkozni és a többi vezérlést a QtQml \texttt{C++} API-ján keresztül
\texttt{C++} nyelven megvalósítani.
\cite{bib:qt-doc-qt-qml}

Habár a QtQml modul rendelkezésünkre bocsájtja a \texttt{QML} deklaratív nyelvet, az még
nem rendelkezik olyan elemekkel, amelyekből össze lehetne állítani egy GUI-t. Ezeket a
GUI elemeket \textbf{QtQuick} és a \textbf{QtQuickControls} modulok szolgálgatják.
Majdnem minden elem megtalálható, ami widget API-ban, sőt még több is. További lehetőség
nyílik a felület elemeinek meganimálására QtQuick API-n keresztül.
A QtQuick \texttt{C++} API-ját használva pedig saját \texttt{QQuickItem}-ek hozhatóak létre,
melyek a QtQml API-ján keresztül beregisztrálhatóak a \texttt{QML} nyelvbe.
\cite{bib:qt-doc-qt-quick}

A QtQuick modul felel a Quick GUI elemek megjelenítéséért, kirajzolásáért.
Korábban (QtQuick1) ez ugyanúgy történt, mint a widget esetén, az elemek a \\
\texttt{QGraphicsView}-ra voltak kirajzolva. Ez a megoldás lassú, különösen, ha egy folyton
változó dinamikus felhasználói felületről beszélünk. A jelenleg is használt QtQuick verzióban
(QtQuick2) megjelent a Qt Quick Scene Graph. A Qt Quick Scene Graph a QtQuick modul része,
ezért nem használható önállóan, viszont a modul nyújt hozzá API-t. A scene graph a UI
elemeiből épített fa struktúra, amelyet aztán a modul OpenGL ES 2.0 vagy OpenGL 2.0
API-n keresztül megjelenít. Emiatt a Quick technológia nem használható olyan platformokon,
ahol nem érhető el legalább az OpenGL 2.0 API.
\cite{bib:qt-doc-qt-quick-scene-graph}

\subsection{Web}
A Qt keretrendszerben nem a QtWebEngine az egyetlen komponens/modul ami a
web-hez, web alkalmazásokhoz nyújt API-t.

\subsubsection{QtWebKit}
A QtWebKit a nyílt forrású WebKit böngésző motor portja. Ez a port lecseréli a WebKit-ben
a hálózati kommunikációt és renderelést megvalósító komponenseket a Qt-s megoldásokra és
a WebKit API felé két fajta Qt-s API-t implementál:
\texttt{C++} API-t a Widget alkalmazásokba való beágyazáshoz és \texttt{QML} API-t a Quick
alkalmazásokhoz.
A \texttt{C++} API szinkron, mivel a single-process architektúrájú WebKit API-ra (WebKit1)
épül. Ezzel szemben a Quick integrációt lehetővé tevő \texttt{QML} API aszinkron, mert az már
a multi-process WebKit2-re épül.

A QtWebKit a Qt 4.7-es verziójában jelent meg. A Chromium--WebKit szétválás után a
fejlesztése leállt és csak karbantartási munkákat végeztek rajta. A Qt 5.5-ös release-ben
már elavultnak számít az 5.6-os verzióból már a bináris csomagokat is eltávolították, csak
a QtWebKit forrása elérhető. A QtWebKit leváltására a Chromium-ra épülő QtWebEngine-t
hozták be.

\subsubsection{QtWebView}
A QtWebKit sosem volt támogatott mobil platformokon (Embedded Linuxon igen) és ez jelenleg
hivatalosan igaz a QtWebEngine-re is. Azonban, a mobil platformok (pl. Android, iOS, WinRT)
biztosítanak natív API-t (WebView) a webes tartalmak megjelenítésére, mivel biztonsági
megfontolásból más módon a mobil alkalmazások nem is férhetnének hozzá web tartalomhoz.

A QtWebView modul ezek fölé a natív web API-k felé nyújt wrapper-t és egységes API-t.
Amennyiben nincs elérhető (vagy támogatott) web API a platformon, akkor a QtWebEngine-t
próbálja használni (fallback). A QtWebView-nak csak \texttt{QML} API-ja van.
\cite{bib:qt-doc-qt-webview}

\subsubsection{QtWebSockets}
A WebSocket egy olyan protokoll, amely kétirányú kommunikációt biztosít a web felett.
A kommunikáció kliens és szerver között történik.
A legtöbb modern böngésző integrálja a WebSocket klienst. A QtWebSockets \texttt{C++} és
\texttt{QML} API-t biztosít mind WebSocket kliens és szerver megvalósításához.
\cite{bib:qt-doc-qt-websockets}

\subsubsection{QtWebChannel}
A QtWebChannel modul a Qt 5.4-es verziójában jelent meg. Olyan alkalmazások esetében,
amelyek beépített HTML tartalmat jelenítenek meg szükség lehet olyan megoldásra,
amelynek segítségével a WebView-ban futó web alkalmazás (\texttt{JavaScript}/\texttt{HTML})
és a natív alkalmazás (\texttt{QML}/\texttt{C++}) kommunikálni tud.

A single-process QtWebKit widget API esetén ennek megvalósítása nem jelentett különösebb
problémát, viszont egy multi-process architektúrára épülő motor (WebKit2 vagy Chromium)
a megvalósítás már sokkal bonyolultabb. Erre a problémára nyújt megoldást a QtWebChannel
modul.

A QtWebChannel segítségével Qt MetaObject-et (\texttt{QObject}) lehet ``meghirdetni'' \\
szerver oldalon, a kliens oldal pedig ezt a MetaObject-et tudja használni. \\
A QtWebChannel modul szerver oldalra nyújt \texttt{QML} és \texttt{C++} API-t,
a kliens oldalra pedig \texttt{JavaScript} API-t. A kliens oldalon megjelenő object a
szerver oldali Qt MetaObject másolata, \texttt{JavaScript} API. A két objektum szinkronizálva
van, a property változtatások és a Qt-s szignálok mindkét oldalon megjelennek.

Ez úgy valósul meg, hogy a szerver oldali API szerializálja Qt MetaObject-et majd átküldi
a kliensnek. A kliens oldali API a szerializált Qt MetaObject-ből \texttt{JavaScript}
object-et gyárt, amely képes kommunikálni az eredeti object-el. A kommunikáció történhet
QtWebSockets segítségével, de akár IPC-n keresztül is.
\cite{bib:qt-doc-qt-webchannel, bib:kdab-qt-webchannel}


\subsection{Release}
Egy Qt release verzió száma 3 részből tevődik össze:
\begin{verbatim}
    MAJOR.MINOR.PATCH
\end{verbatim}
A dolgozatomban bemutatott fejlesztések mind az 5-ös főverzióban (\texttt{MAJOR})
jelentek meg. Ahol ez egyértelmű feltüntetem az alverzió számot is (\texttt{MINOR}).
A Qt közösség előre tervezett menetrend szerint fél évente vált alverzió számot (ad ki új
release-t). Dolgozatom készítése idején a Qt 5.6 a legfrissebb stabil kiadás, viszont egyes
bemutatott funkcionalitások, majd csak a Qt 5.7-ben lesznek elérhetőek.

\section{QtWebEngine}
A QtWebEngine váltotta le a QtWebKit-et a Qt keretrendszer 5.4-es verziójában. A célja
megegyezik a QtWebKit-ével: webes tartalom integrálása és manipulálása Qt alkalmazásban.
A QtWebEngine a Chromium-ra épül, pontosabba a Chromium Content Module unstable API-ja
felé implementál egy stable API-t. Az \ref{fig:chromium-architecture} ábra alapján,
a Chrome böngésző alkalmazás helyére a Chromium stack tetején a QtWebEngine kerül és
az lesz a Chromium Content Module-t beágyazó ``alkalmazás''.

A QtWebEngine fejlesztői forkolták a Chromium-ot és ennek a forknak a karbantartása jelentős
nehézséget okoz a QtWebEngine fejlesztőinek. Körülbelül 6 hetente jelenik meg új Chromium
verzió aminek változik az API-ja. Minden új verzió tartalmazhat biztonsági javításokat is,
amelyeket nem backportolnak korábbi verziókba\footnote{A Chromium-nak nincs LTS (Long Term
Support) verziója}, ezért a rendszeres frissítésekre szükség van. Habár amikor csak
lehetséges ezek a javítások cherry-pick-elve vannak a forkba.

A QtWebEngine-nek legnagyobb részét ez a Chromium forknak a kódja teszi ki, habár sok
nem használt Chromium komponens eltávolításra került (pl. Chrome). Viszont egyes
``backend'' komponensek, amelyek lecserélhetőek voltak QtWebKit-ben Qt modulokra, már
nem lecserélhetőek a Chromium-ban. Ilyen például a Chromium network library.

A web elemek kirajzolását viszont a Qt végzi. A mailbox texture azonosítók segítségével a
QtWebEngine hozzáfér a Chrome Compositor által összeállított textúrákhoz, amelyek a
megosztott OpenGL context-en vannak tárolva.
A textúrákból a QtWebEngine épít scene graph fát (\texttt{QSGNode} tree), amit majd a
Qt Quick Scene Graph fog kirajzolni. Emiatt, a Chromium-ban a GPU process ki van kapcsolva,
mert a GPU-t a Qt használja, ami a Browser process-ben fut (\texttt{switches:kInProcessGPU}).

A scene graph függőség miatt a QtWebEngine nem működik olyan környezetben, ahol nincs
OpenGL ES 2.0 vagy OpenGL 2.0. Ez igaz a QtWebEngine Widget API-jára is, mivel a web tartalom
kirajzolásának megvalósítása közös.

A QtWebEngine tartalmazza a QtWebEngine Process-t és 3 modult: a QtWebEngine és a
QtWebEngineWidgets rendre a Quick és Widget API-kat valósítják meg. A QtWebEngineCore
modul tartalmazza a Chromium forkot és QtWebEngine funkcionalitások közös részét, amin a
Quick és a Widget API-k osztoznak. A QtWebEngine felépítését a
\ref{fig:qtwebengine-architecture} ábra mutatja.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.75]{qtwebengine-architecture}
    \caption{
        \label{fig:qtwebengine-architecture}
        QtWebEngine Architecture (forrás: \url{http://doc.qt.io/}
        \cite{bib:qt-doc-webengine-overview})
    }
\end{figure}

\subsection{Process}
A QtWebEngine Process a Chromium Render Process-t fedi el. Különálló program saját belépési
ponttal (\texttt{main()} függvénnyel), amit a Browser Process indít el. Önálló fordítási
egység, de a hozzátartozó kód a QtWebEngine Core modulban van.
Ez processz felel a web tartalom rendereléséért és a \texttt{JavaScript} kódok
végrehajtásáért. A processz OS X-en és Linux-on sandbox-ban fut, Windowson a sandbox
környezet még nem támogatott.

\subsection{Core}
A QtWebEngine Core modul tartalmazza a Chromium fork-ot és implementálja a \\
Chromium Content API interface-eit. Belső (internal) API-ja elfedi a publikus API-k
(Widget, Quick) elől a Chromium Content API-t, így a publikus API-knak nincsenek közvetlen
Chromium függőségeik. A publikus API-k számára közös adapter interface-t \\
(\texttt{WebContentsAdapterClient}) definiál, amit a publikus API-nak kell megvalósítania.

A modul része a Qt Quick Scene Graph integráció is: ő hozza létre a Chromium-ból
kinyert textúrákból a scene graph node-okat (\texttt{QSGNode}) és épít belőle fát a
megjelenítésre (compositing). Továbbá itt található meg a Browser Process és a QtWebEngine
Process inicializációja (\texttt{WebEngineContext}), a QtWebEngine beállításainak továbbítása
a Chromium felé (\texttt{WebEngineSettings}), controller osztályok az API specifikus
dialog ablakok megvalósításához (\texttt{pl.: JavaScriptDialogController}) és még sok minden
más.

Továbbá, QtWebEngine Core modul függősége Qt WebChannel modul, hogy a publikus API-t
használva tetszőlegese saját Qt-s objektum elérhető legyen a weboldal (vagy webalkalmazás)
számára. Ezáltal a fejlesztő hybrid alkalmazást hozhat létre, amelyben a QtWebEngine-el
megjelenített weboldal, kommunikálhat a QtWebEngine-t beágyazó alkalmazással.
A Qt WebChannel Qt WebSockets-ra épülő backend-jét a Qt WebEngine Core cseréli le úgy,
hogy a kommunikáció a Chromium IPC felett történjen, továbbá beregisztrálja a web channel-t
a V8\footnote{a Chromium JavaScript motorja} API-n keresztül az érintett oldal
\texttt{JavaScript} context-jébe.

A Qt 5.6-os verziója óta a Qt WebEngine Core modul rendelkezik publikus API-val is.
Ez az API a Chromium-hoz enged hozzáférést és jellemzően a Widget vagy Quick API-val kell
együtt használni. Ennélfogva a QtWebEngine Core modulját nem szükséges explicit hozzáadni,
a saját Qt-s alkalmazás projektjéhez, mert a Qt WebEngine Widgets és Qt WebEngine (Quick)
modulok automatikusan behúzzák. Ennek az API-nak része a
\texttt{QtWebEngineCore::initialize()} függvény is, amivel a QtWebEngine-t integráló
alkalmazást ``inicializálni'' kell, azért, hogy a megjelenítéshez használt OpenGL context
a processzek között megosztott legyen (\texttt{Qt::AA\_ShareOpenGLContexts}).

\subsection{Widget és Quick API}
A QtWebEngine Widget és Quick API-ját rendre a \textbf{Qt WebEngine Widgets} és
\textbf{Qt WebEngine} modulok valósítják meg.
Ezek a modulok nem implementálják vagy hívják közvetlenül a Chromium Content API-t,
hanem azt a Qt WebEngine Core modulon keresztül érik el. A két API között előfordulhatnak
funkcionalitásban előfordulhatnak különbségek, például az egyikben elérhető egy API
függvény a másikban még nem.

A publikus API-k megvalósításánál nagyon fontos szempont a bináris kompatibilitás
biztosítása. Ez nem csak annyit jelent, hogy a meglévő API-k nem változnak, hanem a publikus
(exportált) \texttt{C++} osztályok sem mérete, sem pedig az elrendezése (layout) nem
változhat. Ez a felhasználó számára annyit jelent, hogy saját Qt-s alkalmazása alatt
főverzión belül (esetünkben ez az 5-ös) kicserélheti (frissítheti) a Qt library-t anélkül,
hogy az alkalmazását újra kellene buildelni.

A bináris kompatibilitás megőrzése érdekében a publikus API-k implementálásakor
\textit{d-pointer} (vagy más néven \textit{opaque pointer}) tervezési mintát alkalmazunk.
Ez nem csak a QtWebEngine API-jaira igaz, hanem az összes publikus Qt API-ra is.

A tervezési minta lényege az, hogy az API-ban megvalósított logikát egy rejtett
(\textit{private}) osztály tartalmazza. Az API maga egy másik, publikus (\textit{public})
osztály, ami egy pointer-t tartalmaz rejtett osztályra. Ez a pointer a névadó,
\textit{d-pointer} (private data member). Ezáltal az API implementációja ``rejtve'' marad,
az implementációban módosítások nem változtatják a publikus API-t és publikus API header
file-a átláthatóbb, mert nem tartalmaz olyan metódust vagy adattagot, ami nem a publikus
API része.
\cite{bib:qt-wiki-d-pointer}

\subsubsection{Qt WebEngine Widget}
A Qt WebEngine Widget modul C++ osztályokat nyújt widget GUI létrehozására. Az API
fő komponense a \texttt{QWebEngineView} widget, amely a web tartalom megjelenítésért felel.
Minden \texttt{QWebEngineView} objektumhoz egy \texttt{QWebEnginePage} példány tartozik.
A \texttt{QWebEnginePage} API-n keresztül kérdezhető le és változtatható a web oldal
tartalma.

További API-k: \texttt{QWebEngineHistory} a már látogatott oldalak nyilvántartására és
visszatöltésére, \texttt{QWebEngineProfile} weboldal csoportok kezelésére közös
beállításokkal (pl.: ``inkognitó'' mód: \texttt{QWebEngineProfile::isOffTheRecord()}),
\texttt{QWebEngineSettings} a weboldalak beállításainak kezelésére, \\
\texttt{QWebEngineScript} JavaScript-ek beágyazására.

\subsubsection{Qt WebEngine}
A Qt WebEngine ``fő'' modulja a Quick API. QML típusokat definiál QML/Quick alkalmazások
létrehozására. A nagyjából ugyanazok az API-k állnak rendelkezésre, mint a Widget esetén.
Egy fontos eltérést nem számítva: nincs külön \texttt{WebEnginePage} QML típus az oldal
tartalmának kezelésére, hanem annak API-ja is a \texttt{WebEngineView} QML típusba lett
beépítve.


\chapter{Új funkciók a QtWebEngine-ben}

\section{Navigation History}

\begin{itemize}
    \item Hiányzó Quick API megvalósítása
    \item Backward, Forward list model
    \item TODO: Example gyártása?
\end{itemize}
\pagebreak

\section{Find Text}
\begin{itemize}
    \item Csak Quick API
    \item Tesztek portolása QtWebKit-ből
\end{itemize}
\pagebreak

\section{Log Level}
\begin{itemize}
    \item Parancssori kapcsoló
    \item Hibakeresés
    \item \texttt{-{}-log-level}
\end{itemize}
\pagebreak

\section{Test Support API}
\begin{itemize}
    \item Olyan feature-ök tesztelése ami nem jelenhet meg a publikus API-ban
    \item Pl. error page, az error page signal-okat elrejtjük a fejlesztő elől, de tesztelni
        kell.
    \item Előfordulhat, hogy a fejlesztő saját felelőségére használja
    \item Nincs dokumentálva
    \item Fontos lépés a tesztelés szempontjából
    \item Experimental API eltávolítása
\end{itemize}
\pagebreak

\section{Form Validation}
\begin{itemize}
    \item kódnév: Bubi
    \item Message Bubble
    \item HTML5 feature
    \item Chromium callback megvalósítása
    \item Quick és Widget API-ban kétféleképpen megrajzolt buborék
    \item Test Support API teszt
\end{itemize}
\pagebreak

\section{Localization}
\begin{itemize}
    \item Tesztelés miatt: csak angol nyelvű hibaüzenetek
    \item Qt API-n keresztül beállított lokalizáció használata
    \item \texttt{-{}-lang} parancssori kapcsoló lokalizáció felüldefiniálására
    \item \texttt{Chromium} specifikus
\end{itemize}
\pagebreak

\section{Authentication Dialog}
\begin{itemize}
    \item Dialog Quick-hez: \texttt{AuthenticationDialogController}
    \item HTTP authentication
        \begin{itemize}
            \item Simple authentication
            \item Kerberos?
        \end{itemize}
    \item Proxy authentication
    \item Jelszóval védett oldalak esetén dobjon fel ablakot a felhasználó név és jelszó
        megadásához
        \begin{itemize}
            \item pl. \url{wiki.sed.hu}
        \end{itemize}
    \item Probléma, authentikált oldalak esetén nem lehet letölteni a favicon-t
        \begin{itemize}
            \item Widget: QNAM (QNetworkAccessManager) tölti le az ikont, viszont nem kapja
                meg a bejelentkezéshez szükséges credentials-t
            \item Quick: Image QML elem van használva a kép megjelenítésére (ikon támogatás a
                QML-ben nincs).
            \item Az Image QML elem implicit elvégzi a letöltést, ami a felhasználó elől
                rejtve marad => nincs lehetőség authentikációra
        \end{itemize}
    \item Empty credentials és cancel
\end{itemize}
\pagebreak

\section{Favicon Manager}
\begin{itemize}
    \item Ikonok letöltése a Chromium Content API-n keresztül
    \item Az összes ikon letöltése és a legjobb minőségű propagálása
        \begin{itemize}
            \item Az eredeti megvalósításban a touch ikonok nem voltak kezelve
            \item Fontos lehet érintő kijelzős eszközökön vagy akár desktop gépeken is
            \item A history vagy könyvjelzők megjelenítés nagy méretű ikonokkal
        \end{itemize}
    \item Konfigurálhatóság a WebEngineSettings-en keresztül (``Icon Download Modes'')
        \begin{itemize}
            \item Letilthatóak lehessenek az ikonok (sávszélesség, sebesség, saját icon
                manager)
            \item Desktop-on alapból nincsenek bekapcsolva a touch ikonok, de engedélyezni
                lehessen őket
        \end{itemize}
    \item Terv: egy QIcon-ban ``összegyúrva'' az összes ikon
        \begin{itemize}
            \item a felhasználó extra API nélkül könnyedén kiválaszthatja a számára
                megfelelő méretet
            \item Quick esetében az Image átméretezésekor a megfelelő felbontású ikon
                kerül betöltésre
        \end{itemize}
    \item widget API-ra példa QtWebKit-ből
        \begin{itemize}
            \item Azért van szükség módosításra
            \item kész dokumentáció
        \end{itemize}
    \item Quick API-hoz icon image provider
        \begin{itemize}
            \item problémák: hogyan kössük be a manager-t? Hol kössük be a provider-t az
                engine-be?
        \end{itemize}
    \item Hosszabb távú tervek (Qt 5.8)
        \begin{itemize}
            \item API bővítése az elérhető ikonok listázására és explicit letöltésére
            \item Icon database: merevlemezen tárolt ikonok (oldal betöltése előtt is
                elérhető legyen vagy offline módban)
        \end{itemize}
\end{itemize}
\pagebreak


\chapter{Egy példa böngészőalkalmazás megvalósítása}
\textbf{Szempontok:}
\begin{itemize}
    \item Screenshot-ok legyenek a browser-ről
    \item Csak a lényeget részletezni (funkciók megjelenése), a ``körítés'', design-t csak
        megemlíteni
    \item QML példakód a funkciókra
\end{itemize}

\noindent
\textbf{Gondolatok:}
\begin{itemize}
    \item Gyors billentyűre felugró pop-up, amibe az URL-t lehet írni. Animált (halványodik),
        félig áttetsző
    \item Az URL pop-up-nak legyen saját history-ja a memóriában (csak addig él amíg a
        program fut). Indításkor a navigation history-ból legyen inicializálva.
        Automatikus URL kiegészítés.
    \item Legyenek az oldalakról screenshot-ok tárolva. Az URL pop-up a felajánlott oldalakkal
        együtt mutatja a screenshot-ot.
    \item A tabok bal oldali sávon legyenek, vertikális listában. Indok: desktop browser,
        a monitorok szélesek
    \item A tab bar-hoz nem használható a Quick TabView
    \item Tab bar-nak 3 állapota megjelenés szerint:
        \begin{description}
            \item[hidden] Rejtett mód
            \item[compact] ``Keskeny'' mód. Csak ikon, vagy ikon és alatta a title.
            \item[full] A tab teljes szélességében
        \end{description}
    \item Módok között a váltás animált
    \item Jobb oldalt Bookmark Bar hasonló módokkal mint a Tab Bar
    \item A Bookmark Bar-on a legfelső ikon/bejegyzés a menü
    \item Menü dialog-ok animálva jelennek meg, amely mögött a \texttt{WebEngineView}
        megváltozik. Például, összemegy, elhalványul, mindkettő, stb.
    \item Tab váltáskor az aktuális WebEngineView animálva kiúszik a képernyőről és az
        új beúszik (slide?)
    \item A tabok rendezhetőek lehessenek a Tab bar-on.
    \item A tabok csoportokba rendezhetőek legyenek.
    \item A tab felett pár másodpercig tartott egérkurzor preview-t jelenít meg a \\
        \texttt{WebEngineView}-ról
    \item Egyedi dialog ablakok, ha addig elkészül a custom UI delegate
\end{itemize}

\noindent
\textbf{Funkciók megjelenése a példa browserben:}
\begin{description}
    \item[Navigation History] Legyen külön ``navigator'' ablak. Listában lépkedek az
        elemeken, kicsinyített nézetben látszik az oldal (esetleg screenshot?). Klikk-re
        kilép a navigátorból és megnyitja az oldalt.
    \item[Find Text] Ctrl+f shortcut -> animált pop-up. Regexet be lehetne-e adni?
    \item[Log Level] Példa browser indításakor \texttt{-{}-log-level} kapcsolóval
    \item[Test Support API] --
    \item[Form Validation] Screenshot a buborékról
    \item[Localization] Példa browser indításakor \texttt{-{}-lang} kapcsolóval
    \item[Authentication Dialog] Felül definiálni Custom UI delegate-el ha meg lesz
    \item[Favicon Manager] Nagy méretű ikonok: tab, bookmark (kompakt mód), URL pop-up
\end{description}

\addtocontents{toc}{\ }
\chapter*{Eredmények}
\addcontentsline{toc}{section}{Eredmények}
\begin{itemize}
    \item Eredmények:
        \begin{itemize}
            \item Hány darab új feature? Milyen kategória (QtWebKit, Test/Debug, HTML5)?
            \item Teszt lefedettség?
            \item Hány db patch ment be? Melyik milyen jellegű?
                \begin{itemize}
                    \item Új feature
                    \item Új teszt
                    \item Bug fix, build fix, teszt javítás
                    \item Chromium fork karbantartás
                    \item \dots
                \end{itemize}
            \item Chromium fork külön repository, oda is mentek patch-ek
            \item Javításaim között vannak olyanok, amelyek kimondottan platform specifikus
                problémát javítanak. Ezek lefedik a 3 fő desktop platformot: GNU/Linux,
                Windows, OS X
        \end{itemize}
    \item Összegzés?
        \begin{itemize}
            \item Hol tartunk most a QtWebKit leváltással? Mi hiányzik még?
            \item Jelenleg Qt 5.7-en dolgozunk, a felsorolásból mely feature-ök kerülnek
                be az 5.7-be: \textbf{favicon}
            \item Jövő: milyen tervek vannak 5.8-ra?
        \end{itemize}
\end{itemize}


%%% EPILOGUE %%%

\begin{thebibliography}{9}
    \addcontentsline{toc}{section}{Irodalomjegyzék}

    \bibitem{bib:qt-blog-introducing-qtwebengine}
        Qt Blog: Introducing the Qt WebEngine \\
        \href{http://blog.qt.io/blog/2013/09/12/introducing-the-qt-webengine/}
        {http://blog.qt.io/blog/2013/09/12/\\
        introducing-the-qt-webengine/}

    \bibitem{bib:wiki-chromium}
        Wikipedia: Chromium (web browser) \\
        \url{https://en.wikipedia.org/wiki/Chromium_(web_browser)}

    \bibitem{bib:wiki-chrome}
        Wikipedia: Google Chrome \\
        \url{https://en.wikipedia.org/wiki/Google_Chrome}

    \bibitem{bib:wiki-blink}
        Wikipedia: Blink (web engine) \\
        \url{https://en.wikipedia.org/wiki/Blink_(web_engine)}

    \bibitem{bib:chromium-displays-web-pages}
        Chromium: How Chromium Displays Web Pages \\
        \href{https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome}
        {https://www.chromium.org/developers/design-documents/\\
         displaying-a-web-page-in-chrome}

    \bibitem{bib:chromium-blink}
        Chromium: Blink \\
        \url{http://www.chromium.org/blink}

    \bibitem{bib:chromium-gpu}
        Chromium: GPU Accelerated Compositing in Chrome \\
        \href{https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome}
        {https://www.chromium.org/developers/design-documents/\\
        gpu-accelerated-compositing-in-chrome}

    \bibitem{bib:chromium-oopifs}
        Chromium: Rendering and compositing out of process iframes \\
        \href{https://www.chromium.org/developers/design-documents/oop-iframes/oop-iframes-rendering}
        {https://www.chromium.org/developers/design-documents/\\
        oop-iframes/oop-iframes-rendering}

    \bibitem{bib:chromium-texture-mailbox}
        Chromium: CHROMIUM\_texture\_mailbox.txt \\
        \href{https://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_mailbox.txt}
        {https://src.chromium.org/viewvc/chrome/trunk/src/gpu/\\
        GLES2/extensions/CHROMIUM/CHROMIUM\_texture\_mailbox.txt}

    \bibitem{bib:webkit-webkit2}
        WebKit: WebKit2 \\
        \url{https://trac.webkit.org/wiki/WebKit2}

    \bibitem{bib:chromium-multi-process}
        Chromium: Multi-process Architecture \\
        \href{https://www.chromium.org/developers/design-documents/multi-process-architecture}
        {https://www.chromium.org/developers/design-documents/\\
        multi-process-architecture}

    \bibitem{bib:chromium-blog-multi-process}
        Chromium Blog: Multi-process Architecture \\
        \href{http://blog.chromium.org/2008/09/multi-process-architecture.html}
        {http://blog.chromium.org/2008/09/\\
        multi-process-architecture.html}

    \bibitem{bib:chromium-process-models}
        Chromium: Process Models \\
        \href{https://www.chromium.org/developers/design-documents/process-models}
        {https://www.chromium.org/developers/design-documents/\\
        process-models}

    \bibitem{bib:chromium-plugins}
        Chromium: Plugin Architecture \\
        \href{https://www.chromium.org/developers/design-documents/plugin-architecture}
        {https://www.chromium.org/developers/design-documents/\\
        plugin-architecture}

    \bibitem{bib:chromium-content-module}
        Chromium: Content module \\
        \url{https://www.chromium.org/developers/content-module}

    \bibitem{bib:chromium-content-api}
        Chromium: Content API \\
        \href{https://www.chromium.org/developers/content-module/content-api}
        {https://www.chromium.org/developers/content-module/\\
        content-api}

    \bibitem{bib:qt-wiki-about-qt}
        Qt Wiki: About Qt \\
        \url{https://wiki.qt.io/About_Qt}

    \bibitem{bib:qt-wiki-qt-history}
        Qt Wiki: Qt History \\
        \url{https://wiki.qt.io/Qt_History}

    \bibitem{bib:qt-doc-webengine-overview}
        Qt Documentation: Qt WebEngine Overview \\
        \url{http://doc.qt.io/qt-5/qtwebengine-overview.html}

    \bibitem{bib:qt-about-us}
        The Qt Company: About Us \\
        \url{http://www.qt.io/about-us}

    \bibitem{bib:qt-doc-qtmodules}
        Qt Documentation: All Modules \\
        \url{http://doc.qt.io/qt-5/qtmodules.html}

    \bibitem{bib:qt-doc-qt-gui}
        Qt Documentation: Qt GUI \\
        \url{http://doc.qt.io/qt-5/qtgui-index.html}

    \bibitem{bib:qt-doc-user-interfaces}
        Qt Documentation: User Interfaces \\
        \url{http://doc.qt.io/qt-5/topics-ui.html}

    \bibitem{bib:qt-doc-qt-widgets}
        Qt Documentation: Qt Widgets \\
        \url{http://doc.qt.io/qt-5/qtwidgets-index.html}

    \bibitem{bib:qt-doc-qt-qml}
        Qt Documentation: Qt QML \\
        \url{http://doc.qt.io/qt-5/qtqml-index.html}

    \bibitem{bib:qt-doc-qt-quick}
        Qt Documentation: Qt Quick \\
        \url{http://doc.qt.io/qt-5/qtquick-index.html}

    \bibitem{bib:qt-doc-qt-quick-scene-graph}
        Qt Documentation: Qt Quick Scene Graph \\
        \href{http://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph.html}
        {http://doc.qt.io/qt-5/\\
        qtquick-visualcanvas-scenegraph.html}

    \bibitem{bib:qt-doc-qt-webview}
        Qt Documentation: Qt WebView \\
        \url{http://doc.qt.io/qt-5/qtwebview-index.html}

    \bibitem{bib:qt-doc-qt-websockets}
        Qt Documentation: Qt WebSockets \\
        \url{http://doc.qt.io/qt-5/qtwebsockets-index.html}

    \bibitem{bib:qt-doc-qt-webchannel}
        Qt Documentation: Qt WebChannel \\
        \url{http://doc.qt.io/qt-5/qtwebchannel-index.html}

    \bibitem{bib:kdab-qt-webchannel}
        KDAB: Qt WebChannel: bridging the gap between C++/QML and the web \\
        \url{http://doc.qt.io/qt-5/qtwebchannel-index.html}

    \bibitem{bib:qt-wiki-d-pointer}
        Qt Wiki: D-Pointer \\
        \url{https://wiki.qt.io/D-Pointer}

\end{thebibliography}


\chapter*{Nyilatkozat}
\addcontentsline{toc}{section}{Nyilatkozat}

\noindent
Alulírott Varga Péter programtervező informatikus MSc szakos hallgató, kijelentem, hogy a
dolgozatomat a Szegedi Tudományegyetem, Informatikai Tanszékcsoport Szoftverfejlesztés
Tanszékén készítettem, programtervező informatikus MSc diploma megszerzése érdekében.

Kijelentem, hogy a dolgozatot más szakon korábban nem védtem meg, saját munkám eredménye
és csak hivatkozott forrásokat (szakirodalom eszközök, stb.) használtam fel.

Tudomásul veszem, hogy a diplomamunkámat a Szegedi Tudományegyetem Informatikai Tanszékcsoport
könyvtárában, a helyben olvasható könyvek között helyezik el.

\vspace*{2cm}

\begin{tabular}{lc}
    Szeged, \today \hspace{2cm} & \makebox[6cm]{\dotfill} \\
                                & aláírás
\end{tabular}


\chapter*{Köszönetnyílvánítás}
\addcontentsline{toc}{section}{Köszönetnyílvánítás}

\noindent
Szeretnék köszönetet mondani Dr. Kiss Ákos témavezetőmnek a téma kutatása alatt nyújtott
támogatásáért és a diplomamunkám megírásában nyújtott segítségéért.

Ezen kívül szeretnék köszönetet mondani a \textit{The Qt Company} és a
\textit{Szegedi Tudományegyetem Szoftverfejlesztés Tanszék} volt es jelenleg is a QtWebEngine
projekten dolgozó munkatársainak a beszélgetésekért és a közösségnek benyújtott munkám
ellenőrzéséért és befogadásáért.


\chapter*{Mellékletek}
\addcontentsline{toc}{section}{Mellékletek}

\noindent
DVD lemez mely tartalmazza:
\begin{itemize}
    \item \texttt{QtWebEngine} modul \texttt{Git} repository-ját
    \item A bemutatott funkciókat megvalósító patch-eket
    \item A példa böngészőalkalmazás forráskódját
\end{itemize}

\end{document}
