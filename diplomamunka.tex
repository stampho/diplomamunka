\documentclass[12pt]{report}

\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage{t1enc}

\usepackage{times}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}

% Margins
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 237mm

% URL style
\hypersetup{
    colorlinks=false, % Disable colorlinks for not coloring table of contents
    unicode=true,
}

\let\orighref\href
\renewcommand{\href}[2]{%
    \orighref{#1}{\textcolor{blue}{\texttt{#2}}}
}

\let\origurl\url
\renewcommand{\url}[1]{%
    \textcolor{blue}{\origurl{#1}}
}

\newcommand{\todo}[1]{%
    \textcolor{red}{\textbf{TODO}}\footnote{\textcolor{red}{\textbf{TODO:} #1}}
}

\newcommand{\fixme}[1]{%
    \textcolor{red}{\textbf{FIXME}}\footnote{\textcolor{red}{\textbf{FIXME:} #1}}
}

\setdescription{
    style=standard,
    align=right,
    itemindent=2cm,
    labelwidth=2cm,
    leftmargin=2cm,
    %font=\sffamily\bfseries,
}

\def\title{A QtWebEngine modul bővítése és bemutatása saját böngészőalkalmazás segítségével}

\begin{document}

% EMPTY PAGE STYLE
\fancypagestyle{plain}{
    \fancyhf{}
    \fancyfoot[R]{\thepage}
    \renewcommand{\headrulewidth}{0pt}
}

% FOOTER & HEADER
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\title}
\fancyfoot[R]{\thepage}
%\fancyfoot[C]{\thepage}

%%% TITLE PAGE %%%
\thispagestyle{empty}
\begin{center}
    \vspace*{1cm}
    {\Large\textbf{Szegedi Tudományegyetem}}

    \vspace{0.5cm}
    {\Large\textbf{Informatikai Tanszékcsoport}}

    \vspace{3.8cm}
    {\LARGE\textbf{\title}}

    \vspace{3.6cm}
    {\Large Diplomamunka}

    \vspace{4cm}
    \begin{large}
        \begin{tabular}{c@{\hspace{4cm}}c}
            \emph{Készítette:}      & \emph{Témavezető:}        \\
            \textbf{Varga Péter}    & \textbf{Dr. Kiss Ákos}    \\
            programtervező          & egyetemi adjunktus        \\
            informatikus szakos     &                           \\
            hallgató                &
        \end{tabular}
    \end{large}

    \vspace*{2.3cm}
    \begin{Large}
        Szeged

        \vspace{2mm}
        2016
    \end{Large}
\end{center}


%%% TABLE OF CONTENTS %%%
\tableofcontents

%%% PROLOGUE %%%

\chapter*{Feladatkiírás}
\addcontentsline{toc}{section}{Feladatkiírás}

\noindent
A \texttt{QtWebEngine} modul bővítése úgy, hogy a \texttt{QtWebKit} modult használó
fejlesztők könnyen portolhassák a projektjüket \texttt{QtWebEngine}-re.
Továbbá, olyan új funkciók megvalósítása is fontos, amelyek hozzásegítik a
\texttt{QtWebEngine}-t, hogy lépést tartson a fejlődő web technológiákkal (pl. HTML5).
Az újonnan implementált funkciókat tesztelni kell.

\bigskip
\noindent
A tesztelésre lehetőséget nyújt a \texttt{Qt auto test}
keretrendszere, viszont bizonyos funkciók nem tesztelhetőek megfelelően \texttt{auto}
tesztekkel, továbbá nem biztosítható teljes lefedettség. A probléma kiküszöbölésére
példa alkalmazás(ok) implementálására van szükség, amelyet a fejlesztő használhat
``manuális'' tesztelésre, hibakeresésre, továbbá annak forráskódja a funkciók dokumentálására,
bemutatására is felhasználható.

\bigskip
\noindent
A fejlesztés során az alábbi szempontokat kell figyelembe venni:
\begin{itemize}
    \item Bináris kompatibilitás megtartása korábbi \texttt{QtWebEngine}
        verziókkal: publikus API-ban a változtatások számát minimalizálni kell,
        meglévő API-t (függvény, \\
        property, signal, stb.) módosítani vagy eltávolítani
        nem lehet.
    \item Törekvés kompatibilitásra a \texttt{QtWebKit}-el.
        A \texttt{QtWebEngine}-hez adott új \mbox{API-k} ne térjenek el
        (névben, paraméterezésben, stb.) az eredeti \texttt{QtWebKit} API-tól, hacsak ezt
        az új funkcionalitás bővítése nem indokolja.
    \item Törekedni kell arra, hogy a Quick és Widget API hasonlítson egymásra,
        amennyire csak lehet.
    \item Az új funkcionalitásokhoz \texttt{auto} tesztet kell készíteni,
        ahol ez megoldható.
    \item Qt 5.6-os verziójától minden új funkcionalitást dokumentálni kell.
\end{itemize}


\chapter*{Tartalmi összefoglaló}
\addcontentsline{toc}{section}{Tartalmi összefoglaló}
\begin{itemize}
    \item \textbf{A téma megnevezése:} \\
        \title
    \item \textbf{A megadott feladat megfogalmazása:} \\
        A \texttt{QtWebEngine} modul bővítése új funkciókkal és azok tesztelése a
        \texttt{Qt auto test} keretrendszerének segítségével. Az új funkciók bemutatása
        egy saját böngészőalkalmazás megvalósításával.
    \item \textbf{A megoldási mód:} \\
        Részvétel a \texttt{QtWebEngine} project fejlesztésében. Az új funkciók
        megvalósítása \texttt{C++} nyelven. Egy példa böngészőalkalmazás implementálása
        \texttt{QtQuick} segítségével, \texttt{C++} és \texttt{QML} nyelven.
    \item \textbf{Alkalmazott eszközök, módszerek:} \\
        A fejlesztés \texttt{GNU/Linux} rendszeren, \texttt{QtCreator} fejlesztői
        környezetben (IDE) történt. A hibakereséshez \texttt{GDB}-t használtam.
        \texttt{Makefile}-ok legenerálását a project file-okból a \texttt{qmake} végzi.
        A project fordítása \texttt{Linux}-on a \texttt{GNU Toolchain}-el (\texttt{GCC 5.3}),
        \texttt{Os X}-en \texttt{Xcode} -al (\texttt{Xcode 7.2.1}), \texttt{Windows}-on pedig
        \texttt{MSVC 2013} 32-bites verziójával történt. A verzió-követéshez \texttt{Git}-et
        használtam. A teszteléshez szükséges keretrendszert és a teszteket a \texttt{Qt}
        repository-k tartalmazzák.
    \item \textbf{Elért eredmények:} \\
        A \texttt{QtWebEngine} 8 új funkcióval lett kibővítve. Ebből 4 a \texttt{QtWebKit}-ből
        átvett, 3 a tesztelést és hibakeresést segíti, 1 pedig HTML5 funkció.
    \item \textbf{Kulcsszavak:} \\
        \texttt{QtWebEngine}, \texttt{QtWebKit}, \texttt{Qt}, \texttt{Chromium}, \\
        \texttt{Chromium Content API}, \texttt{Web}, \texttt{HTML5}, \texttt{C++}, \\
        \texttt{Quick}, \texttt{QML}, \texttt{Widget}, \texttt{WebEngineView}
\end{itemize}

%%% CONTENT %%%

\chapter*{Bevezetés}
\addcontentsline{toc}{section}{Bevezetés}
\begin{itemize}
    \item Mi a cél?
    \item Bemutatom a \texttt{Chromium}-ot, a \texttt{Qt}-t és a kettőjük kapcsolatát
    \item Bemutatom, hogy a QtWebEngine fejlesztéséhez milyen funkcionalitásokkal járultam
        hozzá
    \item 1-2 mondat: volt más fejlesztés is: karbantartás, tesztek, bug fix
    \item Miért jó ez? Nem gyors, viszont cross-platform, és könnyű ``látványos'' dolgokat
        készíteni
    \item Könnyű böngészőt készíteni.
        \begin{itemize}
            \item Proof: utolsó fejezet, a példaböngészőről
        \end{itemize}
\end{itemize}

\chapter{Áttekintés: \mbox{Chromium + Qt = QtWebEngine}}

\section{Chromium}
A \texttt{Chromium} a Google által fejlesztett, nyílt forrású web böngésző projekt. Nagy
része \texttt{C++} nyelven íródott. Támogatja napjaink legnépszerűbb operációs rendszereit
(``Cross-Platform''), legyen az desktop (Windows, Linux, OS X) vagy mobil (Android, iOS,
QNX).
A \texttt{Chromium} nem egy böngésző alkalmazás, hanem egy tabokat használó ablakkezelő
vagy shell a web-hez.
\cite{bib-wiki-chromium}

\subsection{Chrome}
A Google saját \texttt{Chromium}-ra épülő böngésző alkalmazása a \texttt{Google Chrome}.
Ez az alkalmazás \texttt{Chromium}-mal szemben nem nyílt forrású, viszont a böngésző
megvalósításának nagy része a \texttt{Chromium} projektben megtalálható.
A \texttt{Chrome} nem nyílt részei például a beépített \texttt{Adobe Flash Player}
(\texttt{Pepper Flash Player}) és az automatikus frissítésekért felelős modul
(\texttt{GoogleUpdate}). \cite{bib-wiki-chrome} \\
Egy másik, népszerű \texttt{Chromium}-ra épülő böngésző alkalmazás az \texttt{Opera}.

\subsection{Blink}
A \texttt{Chromium} 28-as verziójától kezdve a \texttt{Blink} böngésző motort használja.
A böngésző motor elsődleges feladata a webes tartalom megjelenítése a képernyőn. Talán
ebből is látszik, hogy a \texttt{Blink} talán a legfontosabb komponense
a \texttt{Chromium}-nak. A \texttt{Chromium} a 28-es verzió előtt \texttt{WebKit}-et
használt, a Google ezt a projektet forkolta és nevezte el \texttt{Blink}-nek. Pontosabban,
a \texttt{Blink} nem a teljes \texttt{WebKit} forkja, hanem csak annak egy részének, a
\texttt{WebCore}-nak.
\cite{bib-wiki-blink}

A \texttt{Blink} nem tartalmazza a \texttt{WebKit}-ben alkalmazott multi-processz
architektúrát és sandboxing-ot, ezek a feladatok a \texttt{Chromium} más szintjein jelennek
meg így egyszerűbbé téve a \texttt{Blink} implementációját. Továbbá, a \texttt{WebKit} része
a \texttt{JavaScriptCore} JavaScript motor is, ami a \texttt{Blink}-be már nem került bele,
hiszen a \texttt{Chromium}-nak van sajátja, a \texttt{V8}.
Ettől eltekintve a \texttt{Blink} még mindig nagyon hasonlít a
\texttt{WebCore}-ra/\texttt{WebKit}-re, a \texttt{Chromium}
forrásában és könyvtár struktúrájában még mindig \texttt{WebKit} néven hivatkoznak erre a
komponensre. Például, a \texttt{Blink} forrása a \\
\texttt{third\_party/WebKit} könyvtárban van.
\cite{bib-chromium-displays-web-pages, bib-chromium-blink}

Már említettem, hogy a \texttt{Blink}, mint böngésző motor felel a webes tartalmak
megjelenítésért. Ennek működése fontos a \texttt{QtWebEngine} szempontjából, ezért ezt itt
röviden részletezném.
A \texttt{Blink} a web oldal tartalmát feldolgozza (parse-olja), és a HTML elemekből
\texttt{Node} objektumokat gyárt. Ezeket a \texttt{Node}-okat egy fába rendezi, amit
\texttt{DOM} (Document Object Model) fának hívnak. A fának a gyökér \texttt{Node}-ja mindig,
az úgynevezett, \texttt{Document Node}. A \texttt{DOM} fa építése során, a motor, minden
megjeleníthető \texttt{Node}-hoz egy \texttt{RenderObject}-et rendel. A \texttt{DOM} fa
építésével párhuzamosan egy másik fát is épít a \texttt{RenderObject}-ekből, a
\texttt{Render Tree}-t. A \texttt{RenderObject} ``tudja'', hogyan kell a \texttt{Node}-ot
megjeleníteni. Továbbá, bizonyos \texttt{RenderObject}-hez \texttt{RenderLayer}-t is
rendel, amiből egy újabb fát épít: \texttt{RenderLayer Tree}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{rendering_trees}
    \caption{
        \label{fig-rendering-trees}
        Rendering Trees (forrás: \url{https://www.chromium.org} \cite{bib-chromium-oopifs})
    }
\end{figure}

Ahogy az \ref{fig-rendering-trees} ábrán is látszik a \texttt{DOM Tree} és a
\texttt{Render Tree} szinte azonos, csak a \texttt{Render Tree} csak a megjeleníthető
\texttt{Node}-okat tartalmazza. Míg a \texttt{RenderLayer Tree} a \texttt{Render Tree} egy
lecsupaszított változata, amit a \texttt{renderer} fog használni a rajzoláshoz.
A \texttt{RenderLayer}-ből elérhetőek a \texttt{RenderObject}-ek (amik tudják, hogyan
kell kirajzolni a tartalmat), a \texttt{RenderLayer Tree} pedig hordozza azt az információt,
hogy milyen sorrendben kell rajzolni és, hogy milyen átfedések lehetnek.

Az, hogy a rajzolás ezek után hogyan történik az függ attól, hogy van e elérhető hardveres
gyorsítás. Ha nincs, akkor szoftveres renderelés történik úgy, hogy a \\
\texttt{RenderLayer Tree}-n keresztül megfelelő sorrendben bejárják a
\texttt{RenderObject}-eket és kirajzoltatják őket egy közös bitmap-re. Ha kész, ez a bitmap
lesz elküldve a böngésző alkalmazásnak (pl. \texttt{Chrome}) megjelenítésre. Szoftveres
renderelés esetén a rajzolást a \texttt{Skia} grafikus motor végzi.

Ha van elérhető hardveres gyorsítás, akkor az eljárás valamivel bonyolultabb. Az egésznek az
a lényege, hogy a \texttt{RenderObject} nem bitmap-be ``rajzolja bele magát'', hanem 3D API-n
keresztül (\texttt{OpenGL} vagy Windows-on \texttt{D3D}) utasításokat küld közvetlenül a
GPU-nak (grafikus processzor). Ezt az eljárást már a \texttt{Chrome Compositor} (\texttt{CC})
végzi.
\cite{bib-chromium-gpu, bib-chromium-oopifs}

\subsection{Chrome Compositor (CC)}
A \texttt{Chrome Compositor} már nem része a \texttt{Blink}-nek.
Ennek az az oka, hogy most már a \texttt{Chromium} a browser UI megrajzolásához is a
\texttt{Chrome Compositor}-t használja.
Ahhoz, hogy a compositor ki tudja rajzolni a \texttt{DOM}-ban tárolt tartalmat,
további layer absztrakciókra van szükség:
\begin{center}
    \texttt{RenderLayers} $\rightarrow$ \texttt{GraphicsLayers} $\rightarrow$
    \texttt{WebLayers} $\rightarrow$ \texttt{CC Layers}
\end{center}

A compositor a végeredményt nem bitmap-be, hanem textúrába ``rajzolja''. Az elkészült
textúrák a GPU memóriájában vannak tárolva és \texttt{texture mailbox} segítségével
azonosítják. A \texttt{texture mailbox} egy \texttt{OpenGL extension}, ami egyedi és globális
string azonosítót rendel a textúrához és lehetővé teszi, hogy más \texttt{OpenGL context}-en
is elérhető legyen a textúra, ami normális esetben nem lenne megosztva.
\cite{bib-chromium-gpu, bib-chromium-oopifs}

A \texttt{texture mailbox}-nak hála az összeállított képet nem kell az \\
\texttt{IPC}-n (\texttt{Inter-Process Communication}) keresztül megosztani a processzek között
(mint a szoftveres rendering esetében), hanem a GPU memórián keresztül bármelyik
processz hozzáférhet a textúrához.
\cite{bib-chromium-texture-mailbox}

\subsection{Multi-processz Architektúra}
\texttt{Chromium} volt az egyik első olyan böngésző, ami úgy lett megtervezve, hogy több
processzre legyen bontva. A \texttt{WebKit} multi-processzt támogató API-ja (\texttt{WebKit2})
is a \texttt{Chromium}-ról mintázta a multi-processz modelljét.
\cite{bib-webkit-webkit2}
Arról már volt szó, hogy ez az API nem került át a \texttt{Blink}-be,
viszont említést érdemel, mivel a \texttt{QtWebEngine} elődjének, a \texttt{QtWebKit}-nek
\texttt{Quick} API-ja a \texttt{WebKit2}-re épül.

A multi-processz architektúrán alapuló böngésző alapgondolata az, hogy a böngészőalkalmazás
UI-ért felelős része saját processzben fut, míg a web oldal(ak) megjelenítésért egy másik
(vagy több) processz felel. Ennek több előnye is van: \cite{bib-chromium-blog-multi-process}
\begin{enumerate}
    \item Felhasználói élmény: Előfordulhat, hogy egy oldal töltése egy script
        vagy webalkalmazás futtatása nagyon leterheli a böngészőt.
        Ez hagyományos ``egy-processzes'' browserek
        esetében nagy valószínűséggel azzal is jár, hogy a UI kevésbé lesz ``reszponzív''.
        Multi-processz architektúra esetén ez kevésbé valószínű.
    \item Biztonság: Bizonyos processzek sandboxolva vannak: a külön processzben futó
        webalkalmazások hozzáférése korlátozott a rendszer erőforrásaihoz és egymáshoz.
    \item Hibatűrés: A tabok és pluginok külön-külön processzben futnak. Ha egy oldal
        betöltésekor vagy egy bővítmény futtatásakor hiba történik, vagy elszáll, az nem
        fogja magával rántani az egész böngészőt.
\end{enumerate}

A \texttt{Chromium}-ban 4-féle processzt különböztetünk meg. A processzek egymással
\texttt{IPC}-n keresztül kommunikálnak.

\subsubsection{Browser Process}
\begin{itemize}
    \item main process
\end{itemize}

\subsubsection{Render Process}
\begin{itemize}
    \item renderer nagyon komplex, előfordul crash
    \item single process
    \item sandbox
    \item render process per tab
    \item ha elszáll -> sad tab
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{sad_tab}
    \caption{
        \label{fig-sad-tab}
        Sad Tab (forrás: \url{https://googlesystem.blogspot.com} \cite{bib-sad-tab})
    }
\end{figure}

\subsubsection{Plugin Process}
\begin{itemize}
    \item NPAPI
\end{itemize}

\subsubsection{GPU Process}
\begin{itemize}
    \item Mit is csinál -> compositing on GPU
    \item Security: nem férhet akárki hozzá a GPU-hoz
    \item Direct 3D API calls (D3D, OpenGL)
    \item kDisableGPU
\end{itemize}

\subsection{Chromium Content Module}
\begin{itemize}
    \item WebKit-hez képest a különbség -> WebKit-től eltérő megközelítés
    \item Content API
    \item Unstable API
    \item Mit is jelent ez?
    \item Felépítés
    \item Design Pattern
        \begin{itemize}
            \item Delegate interfaces
            \item Observer interfaces
            \item Callbacks
        \end{itemize}
\end{itemize}

\subsection{Felépítés}
Ábra ide

\subsection{Verzió?}
Jelenleg hanyas verzió? Esetleg pár szó a releasekről?


\section{Qt}
\begin{itemize}
    \item Mi ez?
        \subitem Cross-platform, open source, fejlesztő környezet, framework
        \subitem \texttt{C++} függvénykönyvtár
    \item Egy kis történelem:
        \subitem Trolltech -> Nokia -> Digia -> The Qt Company
    \item GUI fejlesztés. 2 fajta megközelítés:
        \begin{enumerate}
            \item Widget
            \item Quick
        \end{enumerate}
    \item Verziók, hol tartunk, honnan jöttünk?
    \item Moduláris felépítés
\end{itemize}

\subsection{Qt Web}
\begin{itemize}
    \item Az Allan féle előadásból mehet egy kis áttekintés
    \item QtWebKit
    \item QtWebView (natív WebView, Android)
    \item QWebChannel
    \item QtWebEngine
    \item etc.
\end{itemize}

\section{QtWebEngine}
\begin{itemize}
    \item Qt module
    \item Ez az unstable API felé húzott stable API
    \item ``Együttműködés'' (integrálhatóság) más Qt API-kal
    \item OpenGL nélkül nem megy
    \item SceneGraph
    \item Qt függőségek
        \begin{itemize}
            \item qtbase
            \item qtdeclarative
            \item \dots
        \end{itemize}
    \item Karbantartási munkák: rendszeres Chromium update
\end{itemize}

\subsection{QtWebEngine Process}
\begin{itemize}
    \item Hogyan indul?
    \item Miért felel?
        \begin{itemize}
            \item Rendering
            \item etc.
        \end{itemize}
    \item IPC kommunikáció a processzek között
    \item Thread-ek
    \item Single Process mode
\end{itemize}

\subsection{QtWebEngine Core}
\begin{itemize}
    \item Mi van benne?
    \item Új (5.7): publikus API, mire jó?
    \item Design Pattern
        \begin{itemize}
            \item Delegate osztályok
            \item Adapterek
        \end{itemize}
    \item \dots
\end{itemize}

\subsection{QtWebEngine API}
\begin{itemize}
    \item D pointeres dolog (private class-ok)
    \item Bináris kompatibilitás
    \item Miért a 2 API?
    \begin{itemize}
        \item A Quick a fontosabb
        \item A 2 API között vannak funkcióbeli különbségek (``az egyik tudja, a másik nem'')
    \end{itemize}
\end{itemize}

\subsubsection{Widget}
\begin{itemize}
    \item Szinkron API -> könnyebb tesztelés
\end{itemize}

\subsubsection{Quick}
\begin{itemize}
    \item Aszinkron API -> állandó probléma a tesztelésnél
        \begin{itemize}
            \item Bizonyos események (signal-ok) bekövetkezésének a sorrendje nem garantált
        \end{itemize}
\end{itemize}

\section{Összegzés}
\begin{itemize}
    \item TODO: egy ábra jöhet a felépítésről
    \item Hogyan kapcsolódnak a részek egymáshoz?
\end{itemize}


\chapter{Új funkciók a QtWebEngine-ben}

\section{Navigation History}

\begin{itemize}
    \item Hiányzó Quick API megvalósítása
    \item Backward, Forward list model
    \item TODO: Example gyártása?
\end{itemize}
\pagebreak

\section{Find Text}
\begin{itemize}
    \item Csak Quick API
    \item Tesztek portolása QtWebKit-ből
\end{itemize}
\pagebreak

\section{Log Level}
\begin{itemize}
    \item Parancssori kapcsoló
    \item Hibakeresés
    \item \texttt{-{}-log-level}
\end{itemize}
\pagebreak

\section{Test Support API}
\begin{itemize}
    \item Olyan feature-ök tesztelése ami nem jelenhet meg a publikus API-ban
    \item Pl. error page, az error page signal-okat elrejtjük a fejlesztő elől, de tesztelni
        kell.
    \item Előfordulhat, hogy a fejlesztő saját felelőségére használja
    \item Nincs dokumentálva
    \item Fontos lépés a tesztelés szempontjából
    \item Experimental API eltávolítása
\end{itemize}
\pagebreak

\section{Form Validation}
\begin{itemize}
    \item kódnév: Bubi
    \item Message Bubble
    \item HTML5 feature
    \item Chromium callback megvalósítása
    \item Quick és Widget API-ban kétféleképpen megrajzolt buborék
    \item Test Support API teszt
\end{itemize}
\pagebreak

\section{Localization}
\begin{itemize}
    \item Tesztelés miatt: csak angol nyelvű hibaüzenetek
    \item Qt API-n keresztül beállított lokalizáció használata
    \item \texttt{-{}-lang} parancssori kapcsoló lokalizáció felüldefiniálására
    \item \texttt{Chromium} specifikus
\end{itemize}
\pagebreak

\section{Authentication Dialog}
\begin{itemize}
    \item Dialog Quick-hez: \texttt{AuthenticationDialogController}
    \item HTTP authentication
        \begin{itemize}
            \item Simple authentication
            \item Kerberos?
        \end{itemize}
    \item Proxy authentication
    \item Jelszóval védett oldalak esetén dobjon fel ablakot a felhasználó név és jelszó
        megadásához
        \begin{itemize}
            \item pl. \url{wiki.sed.hu}
        \end{itemize}
    \item Probléma, authentikált oldalak esetén nem lehet letölteni a favicon-t
        \begin{itemize}
            \item Widget: QNAM (QNetworkAccessManager) tölti le az ikont, viszont nem kapja
                meg a bejelentkezéshez szükséges credentials-t
            \item Quick: Image QML elem van használva a kép megjelenítésére (ikon támogatás a
                QML-ben nincs).
            \item Az Image QML elem implicit elvégzi a letöltést, ami a felhasználó elől
                rejtve marad => nincs lehetőség authentikációra
        \end{itemize}
    \item Empty credentials és cancel
\end{itemize}
\pagebreak

\section{Favicon Manager}
\begin{itemize}
    \item Ikonok letöltése a Chromium Content API-n keresztül
    \item Az összes ikon letöltése és a legjobb minőségű propagálása
        \begin{itemize}
            \item Az eredeti megvalósításban a touch ikonok nem voltak kezelve
            \item Fontos lehet érintő kijelzős eszközökön vagy akár desktop gépeken is
            \item A history vagy könyvjelzők megjelenítés nagy méretű ikonokkal
        \end{itemize}
    \item Konfigurálhatóság a WebEngineSettings-en keresztül (``Icon Download Modes'')
        \begin{itemize}
            \item Letilthatóak lehessenek az ikonok (sávszélesség, sebesség, saját icon
                manager)
            \item Desktop-on alapból nincsenek bekapcsolva a touch ikonok, de engedélyezni
                lehessen őket
        \end{itemize}
    \item Terv: egy QIcon-ban ``összegyúrva'' az összes ikon
        \begin{itemize}
            \item a felhasználó extra API nélkül könnyedén kiválaszthatja a számára
                megfelelő méretet
            \item Quick esetében az Image átméretezésekor a megfelelő felbontású ikon
                kerül betöltésre
        \end{itemize}
    \item widget API-ra példa QtWebKit-ből
        \begin{itemize}
            \item Azért van szükség módosításra
            \item kész dokumentáció
        \end{itemize}
    \item Quick API-hoz icon image provider
        \begin{itemize}
            \item problémák: hogyan kössük be a manager-t? Hol kössük be a provider-t az
                engine-be?
        \end{itemize}
    \item Hosszabb távú tervek (Qt 5.8)
        \begin{itemize}
            \item API bővítése az elérhető ikonok listázására és explicit letöltésére
            \item Icon database: merevlemezen tárolt ikonok (oldal betöltése előtt is
                elérhető legyen vagy offline módban)
        \end{itemize}
\end{itemize}
\pagebreak


\chapter{Egy példa böngészőalkalmazás megvalósítása}
\textbf{Szempontok:}
\begin{itemize}
    \item Screenshot-ok legyenek a browser-ről
    \item Csak a lényeget részletezni (funkciók megjelenése), a ``körítés'', design-t csak
        megemlíteni
    \item QML példakód a funkciókra
\end{itemize}

\noindent
\textbf{Gondolatok:}
\begin{itemize}
    \item Gyors billentyűre felugró pop-up, amibe az URL-t lehet írni. Animált (halványodik),
        félig áttetsző
    \item Az URL pop-up-nak legyen saját history-ja a memóriában (csak addig él amíg a
        program fut). Indításkor a navigation history-ból legyen inicializálva.
        Automatikus URL kiegészítés.
    \item Legyenek az oldalakról screenshot-ok tárolva. Az URL pop-up a felajánlott oldalakkal
        együtt mutatja a screenshot-ot.
    \item A tabok bal oldali sávon legyenek, vertikális listában. Indok: desktop browser,
        a monitorok szélesek
    \item A tab bar-hoz nem használható a Quick TabView
    \item Tab bar-nak 3 állapota megjelenés szerint:
        \begin{description}
            \item[hidden] Rejtett mód
            \item[compact] ``Keskeny'' mód. Csak ikon, vagy ikon és alatta a title.
            \item[full] A tab teljes szélességében
        \end{description}
    \item Módok között a váltás animált
    \item Jobb oldalt Bookmark Bar hasonló módokkal mint a Tab Bar
    \item A Bookmark Bar-on a legfelső ikon/bejegyzés a menü
    \item Menü dialog-ok animálva jelennek meg, amely mögött a \texttt{WebEngineView}
        megváltozik. Például, összemegy, elhalványul, mindkettő, stb.
    \item Tab váltáskor az aktuális WebEngineView animálva kiúszik a képernyőről és az
        új beúszik (slide?)
    \item A tabok rendezhetőek lehessenek a Tab bar-on.
    \item A tabok csoportokba rendezhetőek legyenek.
    \item A tab felett pár másodpercig tartott egérkurzor preview-t jelenít meg a \\
        \texttt{WebEngineView}-ról
    \item Egyedi dialog ablakok, ha addig elkészül a custom UI delegate
\end{itemize}

\noindent
\textbf{Funkciók megjelenése a példa browserben:}
\begin{description}
    \item[Navigation History] Legyen külön ``navigator'' ablak. Listában lépkedek az
        elemeken, kicsinyített nézetben látszik az oldal (esetleg screenshot?). Klikk-re
        kilép a navigátorból és megnyitja az oldalt.
    \item[Find Text] Ctrl+f shortcut -> animált pop-up. Regexet be lehetne-e adni?
    \item[Log Level] Példa browser indításakor \texttt{-{}-log-level} kapcsolóval
    \item[Test Support API] --
    \item[Form Validation] Screenshot a buborékról
    \item[Localization] Példa browser indításakor \texttt{-{}-lang} kapcsolóval
    \item[Authentication Dialog] Felül definiálni Custom UI delegate-el ha meg lesz
    \item[Favicon Manager] Nagy méretű ikonok: tab, bookmark (kompakt mód), URL pop-up
\end{description}

\addtocontents{toc}{\ }
\chapter*{Eredmények}
\addcontentsline{toc}{section}{Eredmények}
\begin{itemize}
    \item Eredmények:
        \begin{itemize}
            \item Hány darab új feature? Milyen kategória (QtWebKit, Test/Debug, HTML5)?
            \item Teszt lefedettség?
        \end{itemize}
    \item Összegzés?
\end{itemize}


%%% EPILOGUE %%%

\begin{thebibliography}{9}
    \addcontentsline{toc}{section}{Irodalomjegyzék}

    \bibitem{bib-wiki-chromium}
        Wikipedia: Chromium (web browser) \\
        \url{https://en.wikipedia.org/wiki/Chromium_(web_browser)}

    \bibitem{bib-wiki-chrome}
        Wikipedia: Google Chrome \\
        \url{https://en.wikipedia.org/wiki/Google_Chrome}

    \bibitem{bib-wiki-blink}
        Wikipedia: Blink (web engine) \\
        \url{https://en.wikipedia.org/wiki/Blink_(web_engine)}

    \bibitem{bib-chromium-displays-web-pages}
        Chromium: How Chromium Displays Web Pages \\
        \href{https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome}
        {https://www.chromium.org/developers/design-documents/\\
         displaying-a-web-page-in-chrome}

    \bibitem{bib-chromium-blink}
        Chromium: Blink \\
        \url{http://www.chromium.org/blink}

    \bibitem{bib-chromium-gpu}
        Chromium: GPU Accelerated Compositing in Chrome \\
        \href{https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome}
        {https://www.chromium.org/developers/design-documents/\\
        gpu-accelerated-compositing-in-chrome}

    \bibitem{bib-chromium-oopifs}
        Chromium: Rendering and compositing out of process iframes \\
        \href{https://www.chromium.org/developers/design-documents/oop-iframes/oop-iframes-rendering}
        {https://www.chromium.org/developers/design-documents/\\
        oop-iframes/oop-iframes-rendering}

    \bibitem{bib-chromium-texture-mailbox}
        Chromium: CHROMIUM\_texture\_mailbox.txt \\
        \href{https://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_mailbox.txt}
        {https://src.chromium.org/viewvc/chrome/trunk/src/gpu/\\
        GLES2/extensions/CHROMIUM/CHROMIUM\_texture\_mailbox.txt}

    \bibitem{bib-webkit-webkit2}
        WebKit: WebKit2 \\
        \url{https://trac.webkit.org/wiki/WebKit2}

    \bibitem{bib-chromium-multi-process}
        Chromium: Multi-process Architecture \\
        \href{https://www.chromium.org/developers/design-documents/multi-process-architecture}
        {https://www.chromium.org/developers/design-documents/\\
        multi-process-architecture}

    \bibitem{bib-chromium-blog-multi-process}
        Chromium Blog: Multi-process Architecture \\
        \href{http://blog.chromium.org/2008/09/multi-process-architecture.html}
        {http://blog.chromium.org/2008/09/\\
        multi-process-architecture.html}

    \bibitem{bib-sad-tab}
        Google Operating System (Unofficial Google Blog): Chrome's New Sad Tab Page \\
        \href{http://googlesystem.blogspot.hu/2011/01/chromes-new-sad-tab-page.html}
        {http://googlesystem.blogspot.hu/2011/01/\\
        chromes-new-sad-tab-page.html}

    \bibitem{bib-chromium-process-models}
        Chromium: Process Models \\
        \href{https://www.chromium.org/developers/design-documents/process-models}
        {https://www.chromium.org/developers/design-documents/\\
        process-models}

\end{thebibliography}


\chapter*{Nyilatkozat}
\addcontentsline{toc}{section}{Nyilatkozat}

\noindent
Alulírott Varga Péter programtervező informatikus MSc szakos hallgató, kijelentem, hogy a
dolgozatomat a Szegedi Tudományegyetem, Informatikai Tanszékcsoport Szoftverfejlesztés
Tanszékén készítettem, programtervező informatikus MSc diploma megszerzése érdekében.

Kijelentem, hogy a dolgozatot más szakon korábban nem védtem meg, saját munkám eredménye
és csak hivatkozott forrásokat (szakirodalom eszközök, stb.) használtam fel.

Tudomásul veszem, hogy a diplomamunkámat a Szegedi Tudományegyetem Informatikai Tanszékcsoport
könyvtárában, a helyben olvasható könyvek között helyezik el.

\vspace*{2cm}

\begin{tabular}{lc}
    Szeged, \today \hspace{2cm} & \makebox[6cm]{\dotfill} \\
                                & aláírás
\end{tabular}


\chapter*{Köszönetnyílvánítás}
\addcontentsline{toc}{section}{Köszönetnyílvánítás}

\noindent
Szeretnék köszönetet mondani Dr. Kiss Ákos témavezetőmnek a téma kutatása alatt nyújtott
támogatásáért és a diplomamunkám megírásában nyújtott segítségéért.

Ezen kívül szeretnék köszönetet mondani a \textit{The Qt Company} és a
\textit{Szegedi Tudományegyetem Szoftverfejlesztés Tanszék} volt es jelenleg is a QtWebEngine
projekten dolgozó munkatársainak a beszélgetésekért és a közösségnek benyújtott munkám
ellenőrzéséért és befogadásáért.


\chapter*{Mellékletek}
\addcontentsline{toc}{section}{Mellékletek}

\noindent
DVD lemez mely tartalmazza:
\begin{itemize}
    \item \texttt{QtWebEngine} modul \texttt{Git} repository-ját
    \item A bemutatott funkciókat megvalósító patch-eket
    \item A példa böngészőalkalmazás forráskódját
\end{itemize}

\end{document}
