\documentclass[12pt]{report}

\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage{t1enc}

\usepackage{times}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}

% Margins
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 237mm

% URL style
\hypersetup{
    colorlinks=false, % Disable colorlinks for not coloring table of contents
    unicode=true,
}

\let\orighref\href
\renewcommand{\href}[2]{%
    \orighref{#1}{\textcolor{blue}{\texttt{#2}}}
}

\let\origurl\url
\renewcommand{\url}[1]{%
    \textcolor{blue}{\origurl{#1}}
}

\newcommand{\todo}[1]{%
    \textcolor{red}{\textbf{TODO}}\footnote{\textcolor{red}{\textbf{TODO:} #1}}
}

\newcommand{\fixme}[1]{%
    \textcolor{red}{\textbf{FIXME}}\footnote{\textcolor{red}{\textbf{FIXME:} #1}}
}

\setdescription{
    style=standard,
    align=right,
    itemindent=1cm,
    labelwidth=1cm,
    leftmargin=1cm,
    before={\renewcommand\makelabel[1]{\bfseries ########1:}},
    %font=\sffamily\bfseries,
}

\def\title{A QtWebEngine modul bővítése és bemutatása saját böngészőalkalmazás segítségével}

\begin{document}

% EMPTY PAGE STYLE
\fancypagestyle{plain}{
    \fancyhf{}
    \fancyfoot[R]{\thepage}
    \renewcommand{\headrulewidth}{0pt}
}

% FOOTER & HEADER
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\title}
\fancyfoot[R]{\thepage}
%\fancyfoot[C]{\thepage}

%%% TITLE PAGE %%%
\thispagestyle{empty}
\begin{center}
    \vspace*{1cm}
    {\Large\textbf{Szegedi Tudományegyetem}}

    \vspace{0.5cm}
    {\Large\textbf{Informatikai Tanszékcsoport}}

    \vspace{3.8cm}
    {\LARGE\textbf{\title}}

    \vspace{3.6cm}
    {\Large Diplomamunka}

    \vspace{4cm}
    \begin{large}
        \begin{tabular}{c@{\hspace{4cm}}c}
            \emph{Készítette:}      & \emph{Témavezető:}        \\
            \textbf{Varga Péter}    & \textbf{Dr. Kiss Ákos}    \\
            programtervező          & egyetemi adjunktus        \\
            informatikus szakos     &                           \\
            hallgató                &
        \end{tabular}
    \end{large}

    \vspace*{2.3cm}
    \begin{Large}
        Szeged

        \vspace{2mm}
        2016
    \end{Large}
\end{center}


%%% TABLE OF CONTENTS %%%
\tableofcontents

%%% PROLOGUE %%%

\chapter*{Feladatkiírás}
\addcontentsline{toc}{section}{Feladatkiírás}

\noindent
A \texttt{QtWebEngine} modul bővítése úgy, hogy a \texttt{QtWebKit} modult használó
fejlesztők könnyen portolhassák a projektjüket \texttt{QtWebEngine}-re.
Továbbá, olyan új funkciók megvalósítása is fontos, amelyek hozzásegítik a
\texttt{QtWebEngine}-t, hogy lépést tartson a fejlődő web technológiákkal (pl. HTML5).
Az újonnan implementált funkciókat tesztelni kell.

\bigskip
\noindent
A tesztelésre lehetőséget nyújt a \texttt{Qt auto test}
keretrendszere, viszont bizonyos funkciók nem tesztelhetőek megfelelően \texttt{auto}
tesztekkel, továbbá nem biztosítható teljes lefedettség. A probléma kiküszöbölésére
példa alkalmazás(ok) implementálására van szükség, amelyet a fejlesztő használhat
``manuális'' tesztelésre, hibakeresésre, továbbá annak forráskódja a funkciók dokumentálására,
bemutatására is felhasználható.

\bigskip
\noindent
A fejlesztés során az alábbi szempontokat kell figyelembe venni:
\begin{itemize}
    \item Bináris kompatibilitás megtartása korábbi \texttt{QtWebEngine}
        verziókkal: publikus API-ban a változtatások számát minimalizálni kell,
        meglévő API-t (függvény, \\
        property, signal, stb.) módosítani vagy eltávolítani
        nem lehet.
    \item Törekvés kompatibilitásra a \texttt{QtWebKit}-el.
        A \texttt{QtWebEngine}-hez adott új \mbox{API-k} ne térjenek el
        (névben, paraméterezésben, stb.) az eredeti \texttt{QtWebKit} API-tól, hacsak ezt
        az új funkcionalitás bővítése nem indokolja.
    \item Törekedni kell arra, hogy a Quick és Widget API hasonlítson egymásra,
        amennyire csak lehet.
    \item Az új funkcionalitásokhoz \texttt{auto} tesztet kell készíteni,
        ahol ez megoldható.
    \item Qt 5.6-os verziójától minden új funkcionalitást dokumentálni kell.
\end{itemize}


\chapter*{Tartalmi összefoglaló}
\addcontentsline{toc}{section}{Tartalmi összefoglaló}
\begin{itemize}
    \item \textbf{A téma megnevezése:} \\
        \title
    \item \textbf{A megadott feladat megfogalmazása:} \\
        A \texttt{QtWebEngine} modul bővítése új funkciókkal és azok tesztelése a
        \texttt{Qt auto test} keretrendszerének segítségével. Az új funkciók bemutatása
        egy saját böngészőalkalmazás megvalósításával.
    \item \textbf{A megoldási mód:} \\
        Részvétel a \texttt{QtWebEngine} project fejlesztésében. Az új funkciók
        megvalósítása \texttt{C++} nyelven. Egy példa böngészőalkalmazás implementálása
        \texttt{QtQuick} segítségével, \texttt{C++} és \texttt{QML} nyelven.
    \item \textbf{Alkalmazott eszközök, módszerek:} \\
        A fejlesztés \texttt{GNU/Linux} rendszeren, \texttt{QtCreator} fejlesztői
        környezetben (IDE) történt. A hibakereséshez \texttt{GDB}-t használtam.
        \texttt{Makefile}-ok legenerálását a project file-okból a \texttt{qmake} végzi.
        A project fordítása \texttt{Linux}-on a \texttt{GNU Toolchain}-el (\texttt{GCC 5.3}),
        \texttt{Os X}-en \texttt{Xcode} -al (\texttt{Xcode 7.2.1}), \texttt{Windows}-on pedig
        \texttt{MSVC 2013} 32-bites verziójával történt. A verzió-követéshez \texttt{Git}-et
        használtam. A teszteléshez szükséges keretrendszert és a teszteket a \texttt{Qt}
        repository-k tartalmazzák.
    \item \textbf{Elért eredmények:} \\
        A \texttt{QtWebEngine} 8 új funkcióval lett kibővítve. Ebből 4 a \texttt{QtWebKit}-ből
        átvett, 3 a tesztelést és hibakeresést segíti, 1 pedig HTML5 funkció.
    \item \textbf{Kulcsszavak:} \\
        \texttt{QtWebEngine}, \texttt{QtWebKit}, \texttt{Qt}, \texttt{Chromium}, \\
        \texttt{Chromium Content API}, \texttt{Web}, \texttt{HTML5}, \texttt{C++}, \\
        \texttt{Quick}, \texttt{QML}, \texttt{Widget}, \texttt{WebEngineView}
\end{itemize}

%%% CONTENT %%%

\chapter*{Bevezetés}
\addcontentsline{toc}{section}{Bevezetés}
A \texttt{QtWebEngine}-t 2013-ban kezdték el fejleszteni a Qt fejlesztői kísérleti jelleggel
a \texttt{WebKit} -- \texttt{Chromium} szétválás után.
A szétválás előtt a \texttt{Qt} csapata a harmadik
legtermékenyebb fejlesztője volt a \texttt{WebKit}-nek, az \texttt{Apple} és a
\texttt{Google} után. A kérdés adott volt: megtartsa e a \texttt{Qt} jól bevált
\texttt{QtWebKit} modulját és maradjon az \texttt{Apple} szárnysegédje, vagy beálljon
az új lehetőségeket és irányt mutató \texttt{Google} mögé azáltal, hogy az ő web
platformjára épít egy új modult. Végül az utóbbi mellett döntöttek és a \texttt{QtWebKit}
projektet parkolópályára helyezték és a \texttt{QtWebEngine} éles lett.
\cite{bib-qt-blog-introducing-qtwebengine}

2014 elején kapcsolódtam be a projektbe és azóta is részmunkaidőben veszek részt a
fejlesztésekben. Az azóta eltelt több, mint 2 év alatt sokat tanultam a \texttt{Qt}-ról,
\texttt{Chromium}-ról és a web technológiákról, úgy egyáltalán. Dolgozatomban az ez idő alatt
gyűjtött tapasztalatokból szeretnék megörökíteni egy szeletet.

A \texttt{QtWebEngine} (korábban \texttt{QtWeKit}) projekt célja egy \texttt{Qt} modul
(függvénykönyvtár) nyújtása a fejlesztők számára, amelynek használatával könnyedén
integrálhatnak böngésző funkcionalitásokat saját \texttt{Qt} alkalmazásaikba
vagy könnyedén valósíthatnak meg \texttt{Qt} platform felett saját böngészőt. Ráadásul,
mindezt úgy tehetik meg, hogy nincs szükségük semmilyen ismeretre arról, hogy egy böngésző,
hogyan működik a motorháztető alatt.

Dolgozatomat 3 részre tagoltam. Az első részben adok áttekintést arról, hogy mi is az a
\texttt{Chromium}, mi a \texttt{Qt}, ezek hogyan kapcsolódnak egymáshoz és hogyan is lesz
ebből \texttt{QtWebEngine}. A második részben összegyűjtöttem 8 olyan funkcionalitást,
amit én adtam hozzá a \texttt{QtWebEngine}-hez. Röviden leírom, hogyan valósítottam meg
őket, mi volt a célom velük és milyen nehézségekkel kellett szembe néznem a
megvalósítás során.

A legutolsó fejezetben szeretném bebizonyítani, hogy könnyű a \texttt{QtWebEngine}-el
böngészőt készíteni. Sajnos a \texttt{Chromium} erőforrás igénye és a magas szintű API
miatt, nem várható el a \texttt{QtWebEngine}-től, hogy lekörözze sebességben és/vagy
memória-fogyasztásban a versenytársakat. A \texttt{QtWebEngine} előnye kétség nélkül
az egyszerű használhatóságban és a cross-platform támogatásban rejlik.


\chapter{Áttekintés: \mbox{Chromium + Qt = QtWebEngine}}

\section{Chromium}
A \texttt{Chromium} a Google által fejlesztett, nyílt forrású web böngésző projekt. Nagy
része \texttt{C++} nyelven íródott. Támogatja napjaink legnépszerűbb operációs rendszereit
(``Cross-Platform''), legyen az desktop (Windows, Linux, OS X) vagy mobil (Android, iOS,
QNX).
A \texttt{Chromium} nem egy böngésző alkalmazás, hanem egy tabokat használó ablakkezelő
vagy shell a web-hez.
\cite{bib-wiki-chromium}

\subsection{Chrome}
A Google saját \texttt{Chromium}-ra épülő böngésző alkalmazása a \texttt{Google Chrome}.
Ez az alkalmazás \texttt{Chromium}-mal szemben nem nyílt forrású, viszont a böngésző
megvalósításának nagy része a \texttt{Chromium} projektben megtalálható.
A \texttt{Chrome} nem nyílt részei például a beépített \texttt{Adobe Flash Player}
(\texttt{Pepper Flash Player}) és az automatikus frissítésekért felelős modul
(\texttt{GoogleUpdate}). \cite{bib-wiki-chrome} \\
Egy másik, népszerű \texttt{Chromium}-ra épülő böngésző alkalmazás az \texttt{Opera}.

\subsection{Blink}
A \texttt{Chromium} 28-as verziójától kezdve a \texttt{Blink} böngésző motort használja.
A böngésző motor elsődleges feladata a webes tartalom megjelenítése a képernyőn. Talán
ebből is látszik, hogy a \texttt{Blink} talán a legfontosabb komponense
a \texttt{Chromium}-nak. A \texttt{Chromium} a 28-es verzió előtt \texttt{WebKit}-et
használt, a Google ezt a projektet forkolta és nevezte el \texttt{Blink}-nek. Pontosabban,
a \texttt{Blink} nem a teljes \texttt{WebKit} forkja, hanem csak annak egy részének, a
\texttt{WebCore}-nak.
\cite{bib-wiki-blink}

A \texttt{Blink} nem tartalmazza a \texttt{WebKit}-ben alkalmazott multi-processz
architektúrát és sandboxing-ot, ezek a feladatok a \texttt{Chromium} más szintjein jelennek
meg így egyszerűbbé téve a \texttt{Blink} implementációját. Továbbá, a \texttt{WebKit} része
a \texttt{JavaScriptCore} JavaScript motor is, ami a \texttt{Blink}-be már nem került bele,
hiszen a \texttt{Chromium}-nak van sajátja, a \texttt{V8}.
Ettől eltekintve a \texttt{Blink} még mindig nagyon hasonlít a
\texttt{WebCore}-ra/\texttt{WebKit}-re, a \texttt{Chromium}
forrásában és könyvtár struktúrájában még mindig \texttt{WebKit} néven hivatkoznak erre a
komponensre. Például, a \texttt{Blink} forrása a \\
\texttt{third\_party/WebKit} könyvtárban van.
\cite{bib-chromium-displays-web-pages, bib-chromium-blink}

Már említettem, hogy a \texttt{Blink}, mint böngésző motor felel a webes tartalmak
megjelenítésért. Ennek működése fontos a \texttt{QtWebEngine} szempontjából, ezért ezt itt
röviden részletezném.
A \texttt{Blink} a web oldal tartalmát feldolgozza (parse-olja), és a HTML elemekből
\texttt{Node} objektumokat gyárt. Ezeket a \texttt{Node}-okat egy fába rendezi, amit
\texttt{DOM} (Document Object Model) fának hívnak. A fának a gyökér \texttt{Node}-ja mindig,
az úgynevezett, \texttt{Document Node}. A \texttt{DOM} fa építése során, a motor, minden
megjeleníthető \texttt{Node}-hoz egy \texttt{RenderObject}-et rendel. A \texttt{DOM} fa
építésével párhuzamosan egy másik fát is épít a \texttt{RenderObject}-ekből, a
\texttt{Render Tree}-t. A \texttt{RenderObject} ``tudja'', hogyan kell a \texttt{Node}-ot
megjeleníteni. Továbbá, bizonyos \texttt{RenderObject}-hez \texttt{RenderLayer}-t is
rendel, amiből egy újabb fát épít: \texttt{RenderLayer Tree}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.46]{rendering_trees}
    \caption{
        \label{fig-rendering-trees}
        Rendering Trees (forrás: \url{https://www.chromium.org} \cite{bib-chromium-oopifs})
    }
\end{figure}

Ahogy az \ref{fig-rendering-trees} ábrán is látszik a \texttt{DOM Tree} és a
\texttt{Render Tree} szinte azonos, csak a \texttt{Render Tree} csak a megjeleníthető
\texttt{Node}-okat tartalmazza. Míg a \texttt{RenderLayer Tree} a \texttt{Render Tree} egy
lecsupaszított változata, amit a \texttt{renderer} fog használni a rajzoláshoz.
A \texttt{RenderLayer}-ből elérhetőek a \texttt{RenderObject}-ek (amik tudják, hogyan
kell kirajzolni a tartalmat), a \texttt{RenderLayer Tree} pedig hordozza azt az információt,
hogy milyen sorrendben kell rajzolni és, hogy milyen átfedések lehetnek.

Az, hogy a rajzolás ezek után hogyan történik az függ attól, hogy van e elérhető hardveres
gyorsítás. Ha nincs, akkor szoftveres renderelés történik úgy, hogy a \\
\texttt{RenderLayer Tree}-n keresztül megfelelő sorrendben bejárják a
\texttt{RenderObject}-eket és kirajzoltatják őket egy közös bitmap-re. Ha kész, ez a bitmap
lesz elküldve a böngésző alkalmazásnak (pl. \texttt{Chrome}) megjelenítésre. Szoftveres
renderelés esetén a rajzolást a \texttt{Skia} grafikus motor végzi.

Ha van elérhető hardveres gyorsítás, akkor az eljárás valamivel bonyolultabb. Az egésznek az
a lényege, hogy a \texttt{RenderObject} nem bitmap-be ``rajzolja bele magát'', hanem 3D API-n
keresztül (\texttt{OpenGL} vagy Windows-on \texttt{D3D}) utasításokat küld közvetlenül a
GPU-nak (grafikus processzor). Ezt az eljárást már a \texttt{Chrome Compositor} (\texttt{CC})
végzi.
\cite{bib-chromium-gpu, bib-chromium-oopifs}

\subsection{Chrome Compositor (CC)}
A \texttt{Chrome Compositor} már nem része a \texttt{Blink}-nek.
Ennek az az oka, hogy most már a \texttt{Chromium} a browser UI megrajzolásához is a
\texttt{Chrome Compositor}-t használja.
Ahhoz, hogy a compositor ki tudja rajzolni a \texttt{DOM}-ban tárolt tartalmat,
további layer absztrakciókra van szükség:
\begin{center}
    \texttt{RenderLayers} $\rightarrow$ \texttt{GraphicsLayers} $\rightarrow$
    \texttt{WebLayers} $\rightarrow$ \texttt{CC Layers}
\end{center}

A compositor a végeredményt nem bitmap-be, hanem textúrába ``rajzolja''. Az elkészült
textúrák a GPU memóriájában vannak tárolva és \texttt{texture mailbox} segítségével
azonosítják. A \texttt{texture mailbox} egy \texttt{OpenGL extension}, ami egyedi és globális
string azonosítót rendel a textúrához és lehetővé teszi, hogy más \texttt{OpenGL context}-en
is elérhető legyen a textúra, ami normális esetben nem lenne megosztva.
\cite{bib-chromium-gpu, bib-chromium-oopifs}

A \texttt{texture mailbox}-nak hála az összeállított képet nem kell az \\
\texttt{IPC}-n (\texttt{Inter-Process Communication}) keresztül megosztani a processzek között
(mint a szoftveres rendering esetében), hanem a GPU memórián keresztül bármelyik
processz hozzáférhet a textúrához.
\cite{bib-chromium-texture-mailbox}

\subsection{Multi-processz Architektúra}
\texttt{Chromium} volt az egyik első olyan böngésző, ami úgy lett megtervezve, hogy több
processzre legyen felosztva. A \texttt{WebKit} multi-processzt támogató
API-ja (\texttt{WebKit2}) is a \texttt{Chromium}-ról mintázta a multi-processz
architektúráját. \cite{bib-webkit-webkit2}
Ez az API a \texttt{Blink}-nek nem része, viszont a \texttt{QtWebEngine} elődjének,
a \texttt{QtWebKit}-nek \texttt{Quick} API-ja a \texttt{WebKit2}-re épül.

A multi-processz architektúrán alapuló böngésző alapgondolata az, hogy a böngészőalkalmazás
UI-ért felelős része saját processzben fut, míg a weboldalak megjelenítésért más
processzek felelnek. Ennek több előnye is van: \cite{bib-chromium-blog-multi-process}
\begin{description}
    \item[Felhasználói élmény]
        Előfordulhat, hogy egy weboldalon futó script (vagy ``webalkalmazás'')
        nagyon leterheli a böngészőt. Ha ez a script és a UI egy processzben fut,
        akkor ezek nagyobb valószínűséggel vonnak el egymástól erőforrást. Ha külön
        processzben, egymástól függetlenül futnak, kisebb valószínűséggel alakul ki
        köztük versenyhelyzet, így a UI nagyobb CPU használatnál is ``reszponzívabb''
        lehet.
    \item[Biztonság]
        Egyes processzek sandbox-ban futhatnak. Ezáltal nem férhetnek hozzá a rendszer
        olyan erőforrásaihoz, ami veszélyes lehet (pl. merevlemez, hálózat,
        videó memória, stb).
        Továbbá a különböző weboldalakat megjelenítő processzek egymástól is el vannak
        különítve, így egy ártalmas oldal, vagy plugin nem férhet hozzá más oldalon használt
        szenzitív információhoz (pl. jelszó).
    \item[Hibatűrés, Robosztusság]
        Ha egy oldal betöltésekor vagy egy bővítmény futtatásakor hiba történik és
        összeomlik, az nem rántja magával a teljes böngészőt. Hiba esetén a UI és más
        megnyitott oldalak, tabok megmaradnak.
    \end{description}

A multi-processz architektúrának hátulütőjei is vannak: ez a megoldás sokkal \\
erőforrás-igényesebb, és a megvalósítás is bonyolultabb (több hibalehetőség).
A processzek használata memória többletköltséggel jár. Továbbá, a futtatható processzek
számát limitálni kell, mert túl sok processz jelentős lassulást okozhat (pl. az ütemező
többletköltsége miatt).

A processzek \texttt{IPC}-n (\texttt{Chromium's IPC System}) keresztül kommunikálnak
egymással. A \texttt{Chromium}-ban 4 fő processz típust különböztetünk meg:

\subsubsection{Browser Process}
Ez az a processz, ahol maga böngésző alkalmazás (UI) fut. Ez felelős megjelenítésért,
a felhasználói események és a tabok kezeléséért. Ez a fő processz, ami a többi processzt
kezeli (indítja, leállítja, stb.) és csak egy van belőle. Hozzáfér a rendszer erőforrásaihoz,
viszont nem tölt be vagy dolgoz fel web tartalmat.

\subsubsection{Render Process}
A renderelő motor egy nagyon összetett és bonyolult szoftver komponens. Szinte lehetetlen
olyat implementálni, ami sosem hibázik és/vagy omlik össze. \cite{bib-chromium-multi-process}
Ezért racionális döntés az egymástól független oldalak renderelését egymástól független
processzekben végrehajtani. Amennyiben egy \texttt{Render Process} összeomlik, arról a
\texttt{Browser Process} értesül és az oldal helyett az \ref{fig-sad-tab} ábrán látható,
úgynevezett ``sad tab'' értesítő felületet.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{sad_tab}
    \caption{
        \label{fig-sad-tab}
        Sad Tab
    }
\end{figure}

Mivel a \texttt{Chromium}-ban a renderelésért a \texttt{Blink} felel, ezért az is a \\
\texttt{Render Process} része. A \texttt{Blink} az ami közvetlenül feldolgozza a webes
tartalmat, ezért jellemzően a \texttt{Render Process}-t sandbox-ban futtatják, így a
potenciálisan kártékony weben futó kódok nem férhetnek hozzá a rendszer erőforrásaihoz.

A \texttt{Chromium}-ban különböző parancssori kapcsolókkal is beállítható processz modellek
vannak definiálva:
\begin{description}
    \item[Process-per-site-instance]
        Minden site\footnote{Site alatt olyan weboldalak csoportját értjük, amelyek
        közös beregisztrált domain néven osztoznak} külön processz.
        Ha ugyanaz a site kétszer van megnyitva, akkor az is két külön processz lesz.
    \item[Process-per-site]
        Különböző site-ok külön processzbe kerülnek. Az előzővel ellentétben, ha egy site
        kétszer van megnyitva, akkor azok közös processzbe kerülnek.
    \item[Process-per-tab]
        Minden tab külön processz. Több tab kerülhet közös processzbe, ha függnek egymástól.
    \item[Single Process]
        A ``hagyományos, egy-processzes'' modell. Nincs külön \texttt{Render Process}.
        A rendering a \texttt{Browser} processzben történik.
\end{description}

Alapértelmezetten a \textit{Process-per-site-instance} modellt használja a böngésző, de
ettől függetlenül előfordulhat, hogy több site is osztozik, ugyanazon a processzen.
Erre vagy akkor van szükség amikor két site hivatkozik script-ből egymásra,
vagy amikor a futó render processzek száma elér egy limitet.
\cite{bib-chromium-process-models}

\subsubsection{Plugin Process}
A pluginok okozzák a legtöbb problémát a böngésző stabilitásának szempontjából. A plugint
egy harmadik fél készíti ezért a \texttt{Chromium}-nak nincs befolyása afelett, hogy milyen
erőforrásokat használ. Ennél fogva, indokolt lépés a pluginokat nem a
\texttt{Browser Process}-ben futtatni. A legtöbb plugin nem futhat sandbox-ban, mivel olyan
képességekkel bővítik a böngészőt, amelyekhez szükség van hozzáférésre a rendszer
erőforrásaihoz. Ezért a \texttt{Render Process}-en kívül szükség van olyan processzre is,
amelyben a pluginok futhatnak.
\cite{bib-chromium-plugins}

\subsubsection{GPU Process}
A renderelés a \texttt{Render Process}-ben történik, viszont ez a processz
sandbox-ban fut és ezért nem küldhet parancsokat GPU-nak. Hardveres gyorsítás esetén
a compositing-ot és a rajzolást egy külön processzben kell végezni, ami nem sandbox-ban fut.
\cite{bib-chromium-gpu} \\
A \texttt{Chromium} úgy is konfigurálható, hogy a \texttt{GPU Process} feladatát a \\
\texttt{Browser Process} lássa el.


\subsection{Chromium Content Module}
A \texttt{Content Module} az, ami megvalósítja az előző fejezetben bemutatott \\
multi-processz architektúrát. Továbbá, ebben van megvalósítva az összes támogatott
web platform funkcionalitás (például: HTML5, WebRTC, WebGL, stb.), illetve
a hardveres GPU gyorsítás. Böngésző alkalmazás specifikus funkcionalitások, nem részei
\texttt{Content Module}-nak. Lényegében csak az van benne, ami a web tartalom
megjelenítéséhez\footnote{\textit{content} = web tartalom} szükséges, azaz olyan kód,
amit minden böngészőt integráló alkalmazásnak szüksége van.
\cite{bib-chromium-content-module}

A modul célja, hogy az opcionális böngésző funkcionalitások (amire nem feltétlenül van
szüksége a beágyazó alkalmazásnak\footnote{ilyen beágyazó alkalmazás például a
\texttt{Google Chrome}}) le legyenek választva, ezáltal megvalósíthatóak legyenek
a beágyazó alkalmazásban anélkül, hogy a \texttt{Chromium} kódját módosítani kellene. Erre
nyújt lehetőséget a \texttt{Chromium Content API}.

\subsubsection{Chromium Content API}
A \texttt{Content API} megtervezésekor a \texttt{WebKit API}-t vették alapul,
hogy a \texttt{WebKit} fejlesztők könnyebben áttérjenek. Az új API \textit{unstable}, ami
azt jelenti, hogy az API minden új kiadásban változhat, ezért a beágyazó alkalmazást is
minden \texttt{Chromium} frissítés után nagy valószínűséggel változtatni kell.

A \texttt{Content Module} a beágyazó alkalmazást interfészeken (Delegate, Observer)
és callback függvényeken keresztül értesíti az eseményekről, változásokról (például,
hol tart a web oldal letöltése vagy sikeres volt-e a letöltés) vagy éppen
kér le adatokat (például, kell megjeleníteni hiba üzenetet, ha nem sikerül letölteni egy
oldalt). Az interfészek metódusainak és a callback függvényeknek törzse üres a
\texttt{Content Module}-ban, ezeket a beágyazó alkalmazásnak kell implementálnia és a
\texttt{Content Module} hívja meg őket szükség esetén.

Ezeken kívül vannak olyan interfészek is, amelyeket a \texttt{Content Module} implementál
(például, oldal betöltése: \textit{LoadURLWithParams} vagy az URL lekérdezése:
\textit{GetVisibleURL}).
Ezek az interfészek \textit{pure abstract} interfészek, mivel csak egy megvalósításuk lehet
és csakis a \texttt{Content Module}-on belül. \cite{bib-chromium-content-api}

\subsubsection{Chromium Content Shell}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{content_shell}
    \caption{
        \label{fig-content-shell}
        Content Shell
    }
\end{figure}

A \ref{fig-content-shell} ábrán látható alkalmazás a \texttt{Content Shell}.
Ez a lehető legegyszerűbb böngészőalkalmazás, ami a \texttt{Content API}-ra épül.
Arra használják, hogy a \\
\texttt{Content Module}-t és a  \texttt{Blink}-et tesztelhessék, debuggolhassák anélkül,
hogy egy teljes böngészőalkalmazást (pl. \texttt{Chrome}) le kellene fordítani.

\subsection{Felépítés}
Az előző fejezet alapján a \texttt{Chromium}-ot 3 rétegre oszthatjuk fel:
\begin{description}
    \item[Chrome]
        Felhasználói felület (UI) és böngészőalkalmazás funkciók
        (pl.: history, könyvjelzők, favicon, stb.)
    \item[Blink]
        Webes tartalom feldolgozása és renderelése. A \texttt{V8} JavaScript motort a \\
        \texttt{Blink}-en keresztül érjük el és közös processzben futnak.
    \item[Content]
        Ez a réteg valósítja meg a multi-processz architektúrát,
        felel a web platform funkciókért és a hardveres GPU gyorsításért.
\end{description}
A \ref{fig-chromium-architecture} ábra mutatja, hogyan is állnak össze ezek a részek egy
egységes egésszé.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{chromium_architecture}
    \caption{
        \label{fig-chromium-architecture}
        Architectural Diagram
        (forrás: \url{https://www.chromium.org} \cite{bib-chromium-content-module})
    }
\end{figure}

Az \ref{fig-chromium-architecture} ábrán a \texttt{Blink} böngésző motor még
\texttt{WebKit}-nek van jelölve.
A legfelső réteg a \texttt{Chrome} (böngészőalkalmazás), helyére a saját beépítő alkalmazás
kerül.

\subsection{Chromium Release}
Egy \texttt{Chromium} release verzió száma 4 részből tevődik össze:
\begin{center}
    \texttt{MAJOR.MINOR.BUILD.PATCH}
\end{center}
A dolgozatomban a fő verzió számra (MAJOR) hivatkozok.
A \texttt{Chromium} közösség előre tervezett menetrend szerint 1-1.5 havonta vált fő
verziószámot. Dolgozatom készítése idején az 51-es verziójú volt a legfrissebb stabil kiadás.
Az itt leírtak erre a verzióra vonatkoznak.


\section{Qt}
A Qt egy nyílt forrású, cross-platform alkalmazás keretrendszer. Úgy ahogy a
\texttt{Chromium} úgy a \texttt{Qt} is elérhető napjaink legnépszerűbb desktop és mobil
operációs rendszerein. Ez a keretrendszer nyújt \texttt{C++} függvénykönyvtárakat (library),
binding-okat más programozási nyelvekhez (pl.: Python, Java), saját programozási nyelvet
(QML), saját integrált fejlesztői környezetet (QtCreator), saját build rendszert
(qmake) és kiterjesztéseket is a \texttt{C++} nyelvhez (pl.: signal-slot model).
\cite{bib-qt-wiki-about-qt}

A \texttt{Qt} első verziója 1995-ben jelent meg \dots
\cite{bib-qt-wiki-qt-history}
\begin{itemize}
    \item Trolltech
    \item Cél: Cross-platform és GUI
    \item 2008: Nokia
    \item 2010: Qt 4.7: QtWebkit, QtQuick (QML)
    \item 2012: Qt 5.0: QtQuick2; Digia
    \item 2013: QtWebEngine
    \item 2014: The Qt Company
\end{itemize}

Qt 5.0 óta moduláris felépítés \dots
\begin{itemize}
    \item bináris kompatibilitás
    \item csak azokat a modulokat linkeljük az alkalmazáshoz, amire szükség van
    \item essentials and add-ons
    \item Git hogyan tükrözi a modularizációt?
\end{itemize}

\subsection{Qt GUI}
GUI fejlesztésre 2 API: a ``hagyományos'' Widget és a ``modern'' Quick \dots

\subsubsection{Widget}
\begin{itemize}
    \item widget elemek
    \item layoutok
    \item Alkalmazás: designer
\end{itemize}

\subsubsection{Quick}
\begin{itemize}
    \item QtQuick2 OpenGL nélkül nem megy
    \item Library: Quick
    \item Declarative language: QML
\end{itemize}

\subsection{Qt Web}
\begin{itemize}
    \item QtWebKit
    \item QtWebView (natív WebView, Android)
    \item QWebChannel
    \item QtWebEngine
    \item etc.
\end{itemize}

\subsection{Qt Release}
\begin{itemize}
    \item Félévente jelennek meg új kiadások
    \item legfrissebb stabil az 5.6
    \item a dolgozatban 5.7
\end{itemize}

\section{QtWebEngine}
\begin{itemize}
    \item Qt module
    \item Unstable \texttt{Chromium Content API} felett egy stable Qt API
    \item ``Együttműködés'' (integrálhatóság) más Qt API-kal
    \item OpenGL nélkül nem megy
    \item SceneGraph
    \item Qt függőségek
        \begin{itemize}
            \item qtbase
            \item qtdeclarative
            \item \dots
        \end{itemize}
    \item Lecsupaszított \texttt{Chromium} fork is a része
\end{itemize}

\subsection{QtWebEngine Process}
\begin{itemize}
    \item Hogyan indul?
    \item Miért felel?
        \begin{itemize}
            \item Rendering
            \item etc.
        \end{itemize}
    \item IPC kommunikáció a processzek között
    \item Thread-ek
    \item Single Process mode
\end{itemize}

\subsection{QtWebEngine Core}
\begin{itemize}
    \item Mi van benne?
    \item Új (5.7): publikus API, mire jó?
    \item Design Pattern
        \begin{itemize}
            \item Delegate osztályok
            \item Adapterek
        \end{itemize}
    \item \dots
\end{itemize}

\subsection{QtWebEngine API}
\begin{itemize}
    \item D pointeres dolog (private class-ok)
    \item Bináris kompatibilitás
    \item Miért a 2 API?
    \begin{itemize}
        \item A Quick a fontosabb
        \item A 2 API között vannak funkcióbeli különbségek (``az egyik tudja, a másik nem'')
    \end{itemize}
\end{itemize}

\subsubsection{Widget}
\begin{itemize}
    \item Szinkron API -> könnyebb tesztelés
\end{itemize}

\subsubsection{Quick}
\begin{itemize}
    \item Aszinkron API -> állandó probléma a tesztelésnél
        \begin{itemize}
            \item Bizonyos események (signal-ok) bekövetkezésének a sorrendje nem garantált
        \end{itemize}
\end{itemize}

\subsubsection{Felépítés}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.75]{qtwebengine_architecture}
    \caption{
        \label{fig-qtwebengine-architecture}
        Qt WebEngine Architecture (forrás: \url{http://doc.qt.io/}
        \cite{bib-qt-doc-webengine-overview})
    }
\end{figure}


\chapter{Új funkciók a QtWebEngine-ben}

\section{Navigation History}

\begin{itemize}
    \item Hiányzó Quick API megvalósítása
    \item Backward, Forward list model
    \item TODO: Example gyártása?
\end{itemize}
\pagebreak

\section{Find Text}
\begin{itemize}
    \item Csak Quick API
    \item Tesztek portolása QtWebKit-ből
\end{itemize}
\pagebreak

\section{Log Level}
\begin{itemize}
    \item Parancssori kapcsoló
    \item Hibakeresés
    \item \texttt{-{}-log-level}
\end{itemize}
\pagebreak

\section{Test Support API}
\begin{itemize}
    \item Olyan feature-ök tesztelése ami nem jelenhet meg a publikus API-ban
    \item Pl. error page, az error page signal-okat elrejtjük a fejlesztő elől, de tesztelni
        kell.
    \item Előfordulhat, hogy a fejlesztő saját felelőségére használja
    \item Nincs dokumentálva
    \item Fontos lépés a tesztelés szempontjából
    \item Experimental API eltávolítása
\end{itemize}
\pagebreak

\section{Form Validation}
\begin{itemize}
    \item kódnév: Bubi
    \item Message Bubble
    \item HTML5 feature
    \item Chromium callback megvalósítása
    \item Quick és Widget API-ban kétféleképpen megrajzolt buborék
    \item Test Support API teszt
\end{itemize}
\pagebreak

\section{Localization}
\begin{itemize}
    \item Tesztelés miatt: csak angol nyelvű hibaüzenetek
    \item Qt API-n keresztül beállított lokalizáció használata
    \item \texttt{-{}-lang} parancssori kapcsoló lokalizáció felüldefiniálására
    \item \texttt{Chromium} specifikus
\end{itemize}
\pagebreak

\section{Authentication Dialog}
\begin{itemize}
    \item Dialog Quick-hez: \texttt{AuthenticationDialogController}
    \item HTTP authentication
        \begin{itemize}
            \item Simple authentication
            \item Kerberos?
        \end{itemize}
    \item Proxy authentication
    \item Jelszóval védett oldalak esetén dobjon fel ablakot a felhasználó név és jelszó
        megadásához
        \begin{itemize}
            \item pl. \url{wiki.sed.hu}
        \end{itemize}
    \item Probléma, authentikált oldalak esetén nem lehet letölteni a favicon-t
        \begin{itemize}
            \item Widget: QNAM (QNetworkAccessManager) tölti le az ikont, viszont nem kapja
                meg a bejelentkezéshez szükséges credentials-t
            \item Quick: Image QML elem van használva a kép megjelenítésére (ikon támogatás a
                QML-ben nincs).
            \item Az Image QML elem implicit elvégzi a letöltést, ami a felhasználó elől
                rejtve marad => nincs lehetőség authentikációra
        \end{itemize}
    \item Empty credentials és cancel
\end{itemize}
\pagebreak

\section{Favicon Manager}
\begin{itemize}
    \item Ikonok letöltése a Chromium Content API-n keresztül
    \item Az összes ikon letöltése és a legjobb minőségű propagálása
        \begin{itemize}
            \item Az eredeti megvalósításban a touch ikonok nem voltak kezelve
            \item Fontos lehet érintő kijelzős eszközökön vagy akár desktop gépeken is
            \item A history vagy könyvjelzők megjelenítés nagy méretű ikonokkal
        \end{itemize}
    \item Konfigurálhatóság a WebEngineSettings-en keresztül (``Icon Download Modes'')
        \begin{itemize}
            \item Letilthatóak lehessenek az ikonok (sávszélesség, sebesség, saját icon
                manager)
            \item Desktop-on alapból nincsenek bekapcsolva a touch ikonok, de engedélyezni
                lehessen őket
        \end{itemize}
    \item Terv: egy QIcon-ban ``összegyúrva'' az összes ikon
        \begin{itemize}
            \item a felhasználó extra API nélkül könnyedén kiválaszthatja a számára
                megfelelő méretet
            \item Quick esetében az Image átméretezésekor a megfelelő felbontású ikon
                kerül betöltésre
        \end{itemize}
    \item widget API-ra példa QtWebKit-ből
        \begin{itemize}
            \item Azért van szükség módosításra
            \item kész dokumentáció
        \end{itemize}
    \item Quick API-hoz icon image provider
        \begin{itemize}
            \item problémák: hogyan kössük be a manager-t? Hol kössük be a provider-t az
                engine-be?
        \end{itemize}
    \item Hosszabb távú tervek (Qt 5.8)
        \begin{itemize}
            \item API bővítése az elérhető ikonok listázására és explicit letöltésére
            \item Icon database: merevlemezen tárolt ikonok (oldal betöltése előtt is
                elérhető legyen vagy offline módban)
        \end{itemize}
\end{itemize}
\pagebreak


\chapter{Egy példa böngészőalkalmazás megvalósítása}
\textbf{Szempontok:}
\begin{itemize}
    \item Screenshot-ok legyenek a browser-ről
    \item Csak a lényeget részletezni (funkciók megjelenése), a ``körítés'', design-t csak
        megemlíteni
    \item QML példakód a funkciókra
\end{itemize}

\noindent
\textbf{Gondolatok:}
\begin{itemize}
    \item Gyors billentyűre felugró pop-up, amibe az URL-t lehet írni. Animált (halványodik),
        félig áttetsző
    \item Az URL pop-up-nak legyen saját history-ja a memóriában (csak addig él amíg a
        program fut). Indításkor a navigation history-ból legyen inicializálva.
        Automatikus URL kiegészítés.
    \item Legyenek az oldalakról screenshot-ok tárolva. Az URL pop-up a felajánlott oldalakkal
        együtt mutatja a screenshot-ot.
    \item A tabok bal oldali sávon legyenek, vertikális listában. Indok: desktop browser,
        a monitorok szélesek
    \item A tab bar-hoz nem használható a Quick TabView
    \item Tab bar-nak 3 állapota megjelenés szerint:
        \begin{description}
            \item[hidden] Rejtett mód
            \item[compact] ``Keskeny'' mód. Csak ikon, vagy ikon és alatta a title.
            \item[full] A tab teljes szélességében
        \end{description}
    \item Módok között a váltás animált
    \item Jobb oldalt Bookmark Bar hasonló módokkal mint a Tab Bar
    \item A Bookmark Bar-on a legfelső ikon/bejegyzés a menü
    \item Menü dialog-ok animálva jelennek meg, amely mögött a \texttt{WebEngineView}
        megváltozik. Például, összemegy, elhalványul, mindkettő, stb.
    \item Tab váltáskor az aktuális WebEngineView animálva kiúszik a képernyőről és az
        új beúszik (slide?)
    \item A tabok rendezhetőek lehessenek a Tab bar-on.
    \item A tabok csoportokba rendezhetőek legyenek.
    \item A tab felett pár másodpercig tartott egérkurzor preview-t jelenít meg a \\
        \texttt{WebEngineView}-ról
    \item Egyedi dialog ablakok, ha addig elkészül a custom UI delegate
\end{itemize}

\noindent
\textbf{Funkciók megjelenése a példa browserben:}
\begin{description}
    \item[Navigation History] Legyen külön ``navigator'' ablak. Listában lépkedek az
        elemeken, kicsinyített nézetben látszik az oldal (esetleg screenshot?). Klikk-re
        kilép a navigátorból és megnyitja az oldalt.
    \item[Find Text] Ctrl+f shortcut -> animált pop-up. Regexet be lehetne-e adni?
    \item[Log Level] Példa browser indításakor \texttt{-{}-log-level} kapcsolóval
    \item[Test Support API] --
    \item[Form Validation] Screenshot a buborékról
    \item[Localization] Példa browser indításakor \texttt{-{}-lang} kapcsolóval
    \item[Authentication Dialog] Felül definiálni Custom UI delegate-el ha meg lesz
    \item[Favicon Manager] Nagy méretű ikonok: tab, bookmark (kompakt mód), URL pop-up
\end{description}

\addtocontents{toc}{\ }
\chapter*{Eredmények}
\addcontentsline{toc}{section}{Eredmények}
\begin{itemize}
    \item Eredmények:
        \begin{itemize}
            \item Hány darab új feature? Milyen kategória (QtWebKit, Test/Debug, HTML5)?
            \item Teszt lefedettség?
            \item Hány db patch ment be? Melyik milyen jellegű?
                \begin{itemize}
                    \item Új feature
                    \item Új teszt
                    \item Bug fix, build fix, teszt javítás
                    \item Chromium fork karbantartás
                    \item \dots
                \end{itemize}
            \item Chromium fork külön repository, oda is mentek patch-ek
            \item Javításaim között vannak olyanok, amelyek kimondottan platform specifikus
                problémát javítanak. Ezek lefedik a 3 fő desktop platformot: GNU/Linux,
                Windows, OS X
        \end{itemize}
    \item Összegzés?
        \begin{itemize}
            \item Hol tartunk most a QtWebKit leváltással? Mi hiányzik még?
            \item Jelenleg Qt 5.7-en dolgozunk, a felsorolásból mely feature-ök kerülnek
                be az 5.7-be: \textbf{favicon}
            \item Jövő: milyen tervek vannak 5.8-ra?
        \end{itemize}
\end{itemize}


%%% EPILOGUE %%%

\begin{thebibliography}{9}
    \addcontentsline{toc}{section}{Irodalomjegyzék}

    \bibitem{bib-qt-blog-introducing-qtwebengine}
        Qt Blog: Introducing the Qt WebEngine \\
        \href{http://blog.qt.io/blog/2013/09/12/introducing-the-qt-webengine/}
        {http://blog.qt.io/blog/2013/09/12/\\
        introducing-the-qt-webengine/}

    \bibitem{bib-wiki-chromium}
        Wikipedia: Chromium (web browser) \\
        \url{https://en.wikipedia.org/wiki/Chromium_(web_browser)}

    \bibitem{bib-wiki-chrome}
        Wikipedia: Google Chrome \\
        \url{https://en.wikipedia.org/wiki/Google_Chrome}

    \bibitem{bib-wiki-blink}
        Wikipedia: Blink (web engine) \\
        \url{https://en.wikipedia.org/wiki/Blink_(web_engine)}

    \bibitem{bib-chromium-displays-web-pages}
        Chromium: How Chromium Displays Web Pages \\
        \href{https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome}
        {https://www.chromium.org/developers/design-documents/\\
         displaying-a-web-page-in-chrome}

    \bibitem{bib-chromium-blink}
        Chromium: Blink \\
        \url{http://www.chromium.org/blink}

    \bibitem{bib-chromium-gpu}
        Chromium: GPU Accelerated Compositing in Chrome \\
        \href{https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome}
        {https://www.chromium.org/developers/design-documents/\\
        gpu-accelerated-compositing-in-chrome}

    \bibitem{bib-chromium-oopifs}
        Chromium: Rendering and compositing out of process iframes \\
        \href{https://www.chromium.org/developers/design-documents/oop-iframes/oop-iframes-rendering}
        {https://www.chromium.org/developers/design-documents/\\
        oop-iframes/oop-iframes-rendering}

    \bibitem{bib-chromium-texture-mailbox}
        Chromium: CHROMIUM\_texture\_mailbox.txt \\
        \href{https://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_mailbox.txt}
        {https://src.chromium.org/viewvc/chrome/trunk/src/gpu/\\
        GLES2/extensions/CHROMIUM/CHROMIUM\_texture\_mailbox.txt}

    \bibitem{bib-webkit-webkit2}
        WebKit: WebKit2 \\
        \url{https://trac.webkit.org/wiki/WebKit2}

    \bibitem{bib-chromium-multi-process}
        Chromium: Multi-process Architecture \\
        \href{https://www.chromium.org/developers/design-documents/multi-process-architecture}
        {https://www.chromium.org/developers/design-documents/\\
        multi-process-architecture}

    \bibitem{bib-chromium-blog-multi-process}
        Chromium Blog: Multi-process Architecture \\
        \href{http://blog.chromium.org/2008/09/multi-process-architecture.html}
        {http://blog.chromium.org/2008/09/\\
        multi-process-architecture.html}

    \bibitem{bib-chromium-process-models}
        Chromium: Process Models \\
        \href{https://www.chromium.org/developers/design-documents/process-models}
        {https://www.chromium.org/developers/design-documents/\\
        process-models}

    \bibitem{bib-chromium-plugins}
        Chromium: Plugin Architecture \\
        \href{https://www.chromium.org/developers/design-documents/plugin-architecture}
        {https://www.chromium.org/developers/design-documents/\\
        plugin-architecture}

    \bibitem{bib-chromium-content-module}
        Chromium: Content module \\
        \url{https://www.chromium.org/developers/content-module}

    \bibitem{bib-chromium-content-api}
        Chromium: Content API \\
        \href{https://www.chromium.org/developers/content-module/content-api}
        {https://www.chromium.org/developers/content-module/\\
        content-api}

    \bibitem{bib-qt-wiki-about-qt}
        Qt Wiki: About Qt \\
        \url{https://wiki.qt.io/About_Qt}

    \bibitem{bib-qt-wiki-qt-history}
        Qt Wiki: Qt History \\
        \url{https://wiki.qt.io/Qt_History}

    \bibitem{bib-qt-doc-webengine-overview}
        Qt Documentation: Qt WebEngine Overview \\
        \url{http://doc.qt.io/qt-5/qtwebengine-overview.html}

\end{thebibliography}


\chapter*{Nyilatkozat}
\addcontentsline{toc}{section}{Nyilatkozat}

\noindent
Alulírott Varga Péter programtervező informatikus MSc szakos hallgató, kijelentem, hogy a
dolgozatomat a Szegedi Tudományegyetem, Informatikai Tanszékcsoport Szoftverfejlesztés
Tanszékén készítettem, programtervező informatikus MSc diploma megszerzése érdekében.

Kijelentem, hogy a dolgozatot más szakon korábban nem védtem meg, saját munkám eredménye
és csak hivatkozott forrásokat (szakirodalom eszközök, stb.) használtam fel.

Tudomásul veszem, hogy a diplomamunkámat a Szegedi Tudományegyetem Informatikai Tanszékcsoport
könyvtárában, a helyben olvasható könyvek között helyezik el.

\vspace*{2cm}

\begin{tabular}{lc}
    Szeged, \today \hspace{2cm} & \makebox[6cm]{\dotfill} \\
                                & aláírás
\end{tabular}


\chapter*{Köszönetnyílvánítás}
\addcontentsline{toc}{section}{Köszönetnyílvánítás}

\noindent
Szeretnék köszönetet mondani Dr. Kiss Ákos témavezetőmnek a téma kutatása alatt nyújtott
támogatásáért és a diplomamunkám megírásában nyújtott segítségéért.

Ezen kívül szeretnék köszönetet mondani a \textit{The Qt Company} és a
\textit{Szegedi Tudományegyetem Szoftverfejlesztés Tanszék} volt es jelenleg is a QtWebEngine
projekten dolgozó munkatársainak a beszélgetésekért és a közösségnek benyújtott munkám
ellenőrzéséért és befogadásáért.


\chapter*{Mellékletek}
\addcontentsline{toc}{section}{Mellékletek}

\noindent
DVD lemez mely tartalmazza:
\begin{itemize}
    \item \texttt{QtWebEngine} modul \texttt{Git} repository-ját
    \item A bemutatott funkciókat megvalósító patch-eket
    \item A példa böngészőalkalmazás forráskódját
\end{itemize}

\end{document}
